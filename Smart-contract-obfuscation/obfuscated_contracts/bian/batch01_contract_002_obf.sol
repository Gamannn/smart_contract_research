pragma solidity ^0.4.16;contract Token { bytes32 public standard; bytes32 public Oxea6ee8d72e13c1d06121a533b114930bd11fd684; bytes32 public Ox5596a69a60d3dccdc80c6711459fd96d507a07a7; mapping (address => uint256) public Ox5eeb6d94559d845f578d1296910c345b4b7532ce; mapping (address => mapping (address => uint256)) public Oxf2b1f5d4ebf292cb03731e3b4745bd44bc7a5ed0; function Ox79b8f1c420b30132eb653538386d3b6f9ca43302(address _to, uint256 _value) returns (bool success); function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success); function Ox0dd448cd164767e83913267d855fa37b25ba1cf2(address _spender, uint256 _value) returns (bool success); function Oxb445800429bcea45a227e78d875cba356e632b42(address _from, address _to, uint256 _value) returns (bool success);}contract Exchange { function assert(bool assertion) { if (!assertion) throw; } function safeMul(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { assert(msg.sender == Ox044c42daa1b02d096eb641287d1966272a53ad9e.owner); _; } function setOwner(address newOwner) onlyOwner { SetOwner(Ox044c42daa1b02d096eb641287d1966272a53ad9e.owner, newOwner); Ox044c42daa1b02d096eb641287d1966272a53ad9e.owner = newOwner; } function getOwner() returns (address out) { return Ox044c42daa1b02d096eb641287d1966272a53ad9e.owner; } function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin { if (nonce < invalidOrder[user]) throw; invalidOrder[user] = nonce; } mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public traded; mapping (bytes32 => bool) public withdrawn; event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s); event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) { if (expiry > 1000000) throw; Ox044c42daa1b02d096eb641287d1966272a53ad9e.inactivityReleasePeriod = expiry; return true; } function Exchange(address feeAccount_) { Ox044c42daa1b02d096eb641287d1966272a53ad9e.owner = msg.sender; Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount = feeAccount_; Ox044c42daa1b02d096eb641287d1966272a53ad9e.inactivityReleasePeriod = 100000; } function setAdmin(address admin, bool isAdmin) onlyOwner { admins[admin] = isAdmin; } modifier onlyAdmin { if (msg.sender != Ox044c42daa1b02d096eb641287d1966272a53ad9e.owner && !admins[msg.sender]) throw; _; } function() external { throw; } function depositToken(address token, uint256 amount) { tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); lastActiveTransaction[msg.sender] = block.number; if (!Token(token).Oxb445800429bcea45a227e78d875cba356e632b42(msg.sender, this, amount)) throw; Deposit(token, msg.sender, amount, tokens[token][msg.sender]); } function Oxc440e97b620b62853a874ea25bdbcbc94152c904() payable { tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value); lastActiveTransaction[msg.sender] = block.number; Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]); } function Ox0f6bd52a0288edff578ca669ea01fc627239c4a5(address token, uint256 amount) returns (bool success) { if (safeSub(block.number, lastActiveTransaction[msg.sender]) < Ox044c42daa1b02d096eb641287d1966272a53ad9e.inactivityReleasePeriod) throw; if (tokens[token][msg.sender] < amount) throw; tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount); if (token == address(0)) { if (!msg.sender.send(amount)) throw; } else { if (!Token(token).Ox79b8f1c420b30132eb653538386d3b6f9ca43302(msg.sender, amount)) throw; } Withdraw(token, msg.sender, amount, tokens[token][msg.sender]); } function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal) onlyAdmin returns (bool success) { bytes32 hash = keccak256(this, token, amount, user, nonce); if (withdrawn[hash]) throw; withdrawn[hash] = true; if (ecrecover(keccak256("\x19Ethereum Signed Message:\n32", hash), v, r, s) != user) throw; if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney; if (tokens[token][user] < amount) throw; tokens[token][user] = safeSub(tokens[token][user], amount); tokens[token][Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount] = safeAdd(tokens[token][Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount], safeMul(feeWithdrawal, amount) / 1 ether); amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether; if (token == address(0)) { if (!user.send(amount)) throw; } else { if (!Token(token).Ox79b8f1c420b30132eb653538386d3b6f9ca43302(user, amount)) throw; } lastActiveTransaction[user] = block.number; Withdraw(token, user, amount, tokens[token][user]); } function Ox5eeb6d94559d845f578d1296910c345b4b7532ce(address token, address user) constant returns (uint256) { return tokens[token][user]; } function trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin returns (bool success) { if (invalidOrder[tradeAddresses[2]] > tradeValues[3]) throw; bytes32 orderHash = keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]); if (ecrecover(keccak256("\x19Ethereum Signed Message:\n32", orderHash), v[0], rs[0], rs[1]) != tradeAddresses[2]) throw; bytes32 tradeHash = keccak256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]); if (ecrecover(keccak256("\x19Ethereum Signed Message:\n32", tradeHash), v[1], rs[2], rs[3]) != tradeAddresses[3]) throw; if (traded[tradeHash]) throw; traded[tradeHash] = true; if (tradeValues[6] > 100 finney) tradeValues[6] = 100 finney; if (tradeValues[7] > 100 finney) tradeValues[7] = 100 finney; if (safeAdd(orderFills[orderHash], tradeValues[4]) > tradeValues[0]) throw; if (tokens[tradeAddresses[0]][tradeAddresses[3]] < tradeValues[4]) throw; if (tokens[tradeAddresses[1]][tradeAddresses[2]] < (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0])) throw; tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]); tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether)); tokens[tradeAddresses[0]][Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount] = safeAdd(tokens[tradeAddresses[0]][Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether)); tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]); tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)); tokens[tradeAddresses[1]][Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount] = safeAdd(tokens[tradeAddresses[1]][Ox044c42daa1b02d096eb641287d1966272a53ad9e.feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)); orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]); lastActiveTransaction[tradeAddresses[2]] = block.number; lastActiveTransaction[tradeAddresses[3]] = block.number; }struct scalar2Vector {uint256 inactivityReleasePeriod;address feeAccount;address owner;bool allowTransactions;uint8 Ox8b909cf50222b236eccb51530ce106c4983ec6bb;uint256 Oxa164b7364e4ea3780e89c99e20a793ee27f16456;}scalar2Vector Ox044c42daa1b02d096eb641287d1966272a53ad9e = scalar2Vector(0, address(0), address(0), false, 0, 0);}