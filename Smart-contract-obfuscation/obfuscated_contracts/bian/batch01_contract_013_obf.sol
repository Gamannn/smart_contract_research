pragma solidity ^0.4.11;library Ox662c7ae2745f255f456a7506548c144e951839b3 { function Ox9e81724bb13d17472aca63a474f9dbd20817a1fc(uint256 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint256 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal returns (uint256) { uint256 Oxd6a290a708c513e399cc55cc9111470862a045f1 = Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 * Oxa23312d21868ec40f7e7a56a278285c20cc0d444; assert(Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 == 0 || Oxd6a290a708c513e399cc55cc9111470862a045f1 / Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 == Oxa23312d21868ec40f7e7a56a278285c20cc0d444); return Oxd6a290a708c513e399cc55cc9111470862a045f1; } function Oxdc92d9dc1bd56fa852e1b2d82fec3628b45bfcd9(uint256 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint256 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal returns (uint256) { uint256 Oxd6a290a708c513e399cc55cc9111470862a045f1 = Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 / Oxa23312d21868ec40f7e7a56a278285c20cc0d444; return Oxd6a290a708c513e399cc55cc9111470862a045f1; } function Ox5973b4f07c6346ebaf253025607ba8504b380b07(uint256 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint256 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal returns (uint256) { assert(Oxa23312d21868ec40f7e7a56a278285c20cc0d444 <= Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4); return Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 - Oxa23312d21868ec40f7e7a56a278285c20cc0d444; } function Ox128041ce74dec0be3c757f11a14b68afb4ba0952(uint256 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint256 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal returns (uint256) { uint256 Oxd6a290a708c513e399cc55cc9111470862a045f1 = Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 + Oxa23312d21868ec40f7e7a56a278285c20cc0d444; assert(Oxd6a290a708c513e399cc55cc9111470862a045f1 >= Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4); return Oxd6a290a708c513e399cc55cc9111470862a045f1; } function max64(uint64 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint64 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal constant returns (uint64) { return Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 >= Oxa23312d21868ec40f7e7a56a278285c20cc0d444 ? Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 : Oxa23312d21868ec40f7e7a56a278285c20cc0d444; } function min64(uint64 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint64 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal constant returns (uint64) { return Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 < Oxa23312d21868ec40f7e7a56a278285c20cc0d444 ? Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 : Oxa23312d21868ec40f7e7a56a278285c20cc0d444; } function max256(uint256 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint256 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal constant returns (uint256) { return Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 >= Oxa23312d21868ec40f7e7a56a278285c20cc0d444 ? Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 : Oxa23312d21868ec40f7e7a56a278285c20cc0d444; } function min256(uint256 Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4, uint256 Oxa23312d21868ec40f7e7a56a278285c20cc0d444) internal constant returns (uint256) { return Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 < Oxa23312d21868ec40f7e7a56a278285c20cc0d444 ? Oxebd5300e9b3f66eb6567f877754f63bc9e2320e4 : Oxa23312d21868ec40f7e7a56a278285c20cc0d444; }}contract Ox77ea79bc25a173a8360275850827c134e6003d56 { function Ox77ea79bc25a173a8360275850827c134e6003d56() { s2c.Ox86b941529c2f50a6e241e81f0d5971f469da0b57 = msg.sender; } modifier Ox19dc80020481b79b6d06b8944dc19910e28dbf76() { require(msg.sender == s2c.Ox86b941529c2f50a6e241e81f0d5971f469da0b57); _; } function Ox2a2d57e3ac56f9f65c6a9142e8ef629d9cc4e6b0(address Ox56eba9656a37a61240e612a4d803564b257b722e) Ox19dc80020481b79b6d06b8944dc19910e28dbf76 { require(Ox56eba9656a37a61240e612a4d803564b257b722e != address(0)); s2c.Ox86b941529c2f50a6e241e81f0d5971f469da0b57 = Ox56eba9656a37a61240e612a4d803564b257b722e; }}contract Haltable is Ox77ea79bc25a173a8360275850827c134e6003d56 { modifier stopInEmergency { require (!s2c.halted); _; } modifier onlyInEmergency { require (s2c.halted); _; } function halt() external Ox19dc80020481b79b6d06b8944dc19910e28dbf76 { s2c.halted = true; } function unhalt() external Ox19dc80020481b79b6d06b8944dc19910e28dbf76 onlyInEmergency { s2c.halted = false; }}contract ERC20Basic { function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);}contract ERC20 is ERC20Basic { function allowance(address Ox86b941529c2f50a6e241e81f0d5971f469da0b57, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed Ox86b941529c2f50a6e241e81f0d5971f469da0b57, address indexed spender, uint256 value);}contract BasicToken is ERC20Basic { using Ox662c7ae2745f255f456a7506548c144e951839b3 for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].Ox5973b4f07c6346ebaf253025607ba8504b380b07(_value); balances[_to] = balances[_to].Ox128041ce74dec0be3c757f11a14b68afb4ba0952(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; }}contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].Ox128041ce74dec0be3c757f11a14b68afb4ba0952(_value); balances[_from] = balances[_from].Ox5973b4f07c6346ebaf253025607ba8504b380b07(_value); allowed[_from][msg.sender] = _allowance.Ox5973b4f07c6346ebaf253025607ba8504b380b07(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; }}/** * @title SimpleToken * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. */contract AhooleeToken is StandardToken { string public name = "Ahoolee Token"; string public symbol = "AHT"; /** * @dev Contructor that gives msg.sender all of existing tokens. */ function AhooleeToken() { s2c.totalSupply = s2c.INITIAL_SUPPLY; balances[msg.sender] = s2c.INITIAL_SUPPLY; }}contract AhooleeTokenSale is Haltable { using Ox662c7ae2745f255f456a7506548c144e951839b3 for uint; string public name = "Ahoolee Token Sale"; AhooleeToken public token; mapping (address => bool) refunded; mapping (address => uint256) saleBalances ; mapping (address => bool) claimed; event GoalReached(uint amountRaised); event SoftCapReached(uint softCap); event NewContribution(address indexed holder, uint256 etherAmount); event Refunded(address indexed holder, uint256 amount); event LogClaim(address indexed holder, uint256 amount, uint price); modifier onlyAfter(uint time) { require (now > time); _; } modifier onlyBefore(uint time) { require (now < time); _; } function AhooleeTokenSale( uint _hardCapLowUSD, uint _hardCapHighUSD, uint _softCapUSD, address _token, address _beneficiary, uint _priceETH, uint _startTime, uint _durationHours ) { s2c.priceETH = _priceETH; s2c.hardCapLowUsd = _hardCapLowUSD; s2c.hardCapHighUsd = _hardCapHighUSD; s2c.softCapUsd = _softCapUSD; calculatePrice(); token = AhooleeToken(_token); s2c.beneficiary = _beneficiary; s2c.startTime = _startTime; s2c.endTime = _startTime + _durationHours * 1 hours; } function calculatePrice() internal{ s2c.hardCapLow = s2c.hardCapLowUsd * 1 ether / s2c.priceETH; s2c.hardCapHigh = s2c.hardCapHighUsd * 1 ether / s2c.priceETH; s2c.softCap = s2c.softCapUsd * 1 ether / s2c.priceETH; } function setEthPrice(uint _priceETH) onlyBefore(s2c.startTime) Ox19dc80020481b79b6d06b8944dc19910e28dbf76 { s2c.priceETH = _priceETH; calculatePrice(); } function () payable stopInEmergency{ assert (msg.value > 0.01 * 1 ether || msg.value == 0); if(msg.value > 0.01 * 1 ether) doPurchase(msg.sender); } function saleBalanceOf(address _owner) constant returns (uint256) { return saleBalances[_owner]; } function claimedOf(address _owner) constant returns (bool) { return claimed[_owner]; } function doPurchase(address _owner) private onlyAfter(s2c.startTime) onlyBefore(s2c.endTime) { require(s2c.crowdsaleFinished == false); require (s2c.collected.Ox128041ce74dec0be3c757f11a14b68afb4ba0952(msg.value) <= s2c.hardCapHigh); if (!s2c.softCapReached && s2c.collected < s2c.softCap && s2c.collected.Ox128041ce74dec0be3c757f11a14b68afb4ba0952(msg.value) >= s2c.softCap) { s2c.softCapReached = true; SoftCapReached(s2c.softCap); } if (saleBalances[msg.sender] == 0) s2c.investorCount++; s2c.collected = s2c.collected.Ox128041ce74dec0be3c757f11a14b68afb4ba0952(msg.value); saleBalances[msg.sender] = saleBalances[msg.sender].Ox128041ce74dec0be3c757f11a14b68afb4ba0952(msg.value); NewContribution(_owner, msg.value); if (s2c.collected == s2c.hardCapHigh) { GoalReached(s2c.hardCapHigh); } } function claim() { require (s2c.crowdsaleFinished); require (!claimed[msg.sender]); uint price = s2c.HARD_CAP_TOKENS * 1 ether / s2c.hardCapLow; if(s2c.collected > s2c.hardCapLow){ price = s2c.HARD_CAP_TOKENS * 1 ether / s2c.collected; } uint tokens = saleBalances[msg.sender] * price; require(token.transfer(msg.sender, tokens)); claimed[msg.sender] = true; LogClaim(msg.sender, tokens, price); } function returnTokens() Ox19dc80020481b79b6d06b8944dc19910e28dbf76 { require (s2c.crowdsaleFinished); uint tokenAmount = token.balanceOf(this); if(s2c.collected < s2c.hardCapLow){ tokenAmount = (s2c.hardCapLow - s2c.collected) * s2c.HARD_CAP_TOKENS * 1 ether / s2c.hardCapLow; } require (token.transfer(s2c.beneficiary, tokenAmount)); } function Oxfb2febc98336615673d377b47a03b9a05d27ab2e() Ox19dc80020481b79b6d06b8944dc19910e28dbf76 { require (s2c.softCapReached); require (s2c.beneficiary.send(s2c.collected)); s2c.crowdsaleFinished = true; } function refund() public onlyAfter(s2c.endTime) { require (!s2c.softCapReached); require (!refunded[msg.sender]); require (saleBalances[msg.sender] != 0) ; uint refund = saleBalances[msg.sender]; require (msg.sender.send(refund)); refunded[msg.sender] = true; s2c.weiRefunded = s2c.weiRefunded.Ox128041ce74dec0be3c757f11a14b68afb4ba0952(refund); Refunded(msg.sender, refund); }struct scalar2Vector {uint256 HARD_CAP_TOKENS;bool crowdsaleFinished;bool softCapReached;uint256 endTime;uint256 startTime;uint256 weiRefunded;uint256 investorCount;uint256 priceETH;uint256 collected;uint256 softCapUsd;uint256 hardCapHighUsd;uint256 hardCapLowUsd;uint256 softCap;uint256 hardCapHigh;uint256 hardCapLow;address beneficiary;uint256 INITIAL_SUPPLY;uint256 decimals;uint256 totalSupply;bool halted;address Ox86b941529c2f50a6e241e81f0d5971f469da0b57;}scalar2Vector s2c = scalar2Vector( 25000000, false, false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, address(0), 100000000 * 1 ether, 18, 0, false, address(0));}