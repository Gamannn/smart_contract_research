pragma solidity ^0.4.18;contract FUTR { uint256[] levels = [ 8771929824561400000000, 19895525330179400000000, 37350070784724800000000, 64114776667077800000000, 98400490952792100000000, 148400490952792000000000, 218400490952792000000000, 308400490952792000000000, 415067157619459000000000, 500067157619455000000000 ]; uint256[] ratios = [ 114, 89, 55, 34, 21, 13, 8, 5, 3, 2 ]; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); event Mined(address indexed _miner, uint _value); event WaitStarted(uint256 endTime); event SwapStarted(uint256 endTime); event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time); event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time); string public name = "Futereum Token"; string public symbol = "FUTR"; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function () external payable { require(msg.sender != address(0) && s2c.tier != 10 && s2c.swap == false && s2c.wait == false); uint256 issued = mint(msg.sender, msg.value); Mined(msg.sender, issued); Transfer(this, msg.sender, issued); } function FUTR() public { _start(); } function _start() internal { s2c.swap = false; s2c.wait = false; s2c.extended = false; s2c.endTime = now + 366 days; s2c.swapTime = s2c.endTime + 30 days; s2c.swapEndTime = s2c.swapTime + 5 days; s2c.endTimeExtended = now + 1096 days; s2c.swapTimeExtended = s2c.endTimeExtended + 30 days; s2c.swapEndTimeExtended = s2c.swapTimeExtended + 5 days; s2c.submittedFeesPaid = 0; s2c._submitted = 0; s2c.reservedFees = 0; s2c.payRate = 0; s2c.tier = 0; MiningStart(s2c.endTime, s2c.swapTime, s2c.swapEndTime); } function restart() public { require(s2c.swap && now >= s2c.endTime); s2c.penalty = this.balance * 2000 / 10000; payFees(); _start(); } function totalSupply() public constant returns (uint) { return s2c._totalSupply; } function mint(address _to, uint256 _value) internal returns (uint256) { uint256 total = s2c._submitted + _value; if (total > s2c.MAX_SUBMITTED) { uint256 refund = total - s2c.MAX_SUBMITTED - 1; _value = _value - refund; _to.transfer(refund); } s2c._submitted += _value; total -= refund; uint256 tokens = calculateTokens(total, _value); balances[_to] += tokens; s2c._totalSupply += tokens; return tokens; } function calculateTokens(uint256 total, uint256 _value) internal returns (uint256) { if (s2c.tier == 10) { return 7400000000; } uint256 tokens = 0; if (total > levels[s2c.tier]) { uint256 remaining = total - levels[s2c.tier]; _value -= remaining; tokens = (_value) * ratios[s2c.tier]; s2c.tier += 1; tokens += calculateTokens(total, remaining); } else { tokens = _value * ratios[s2c.tier]; } return tokens; } function currentTier() public view returns (uint256) { if (s2c.tier == 10) { return 10; } else { return s2c.tier + 1; } } function leftInTier() public view returns (uint256) { if (s2c.tier == 10) { return 0; } else { return levels[s2c.tier] - s2c._submitted; } } function submitted() public view returns (uint256) { return s2c._submitted; } function balanceMinusFeesOutstanding() public view returns (uint256) { return this.balance - (s2c.penalty + (s2c._submitted - s2c.submittedFeesPaid) * 1530 / 10000); } function calulateRate() internal { s2c.reservedFees = s2c.penalty + (s2c._submitted - s2c.submittedFeesPaid) * 1530 / 10000; uint256 tokens = s2c._totalSupply / 1 ether; s2c.payRate = (this.balance - s2c.reservedFees); s2c.payRate = s2c.payRate / tokens; } function _updateState() internal { if (now >= endTs2c.endTime { if(!swaps2c.swap!waits2c.wait { if (extes2c.extended { waits2c.waitrue; endTs2c.endTimewaps2c.swapTimeExtended WaitStarted(endTs2c.endTime } else if (tiers2c.tier10) { waits2c.waitrue; endTs2c.endTimewaps2c.swapTime WaitStarted(endTs2c.endTime } else { endTs2c.endTimendTs2c.endTimeExtended extes2c.extendedrue; MiningExtended(endTs2c.endTimeaps2c.swapTimeaps2c.swapEndTime } } else if (waits2c.wait { swaps2c.swaprue; waits2c.waitalse; if (extes2c.extended { endTs2c.endTimewaps2c.swapEndTimeExtended } else { endTs2c.endTimewaps2c.swapEndTime } SwapStarted(endTs2c.endTime } } } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); _updateState(); if (_to == address(this)) { require(swaps2c.swap if (payRs2c.payRate0) { calulateRate(); } uint256 amount = _value * payRs2c.payRate amount /= 1 ether; balances[msg.sender] -= _value; _tots2c._totalSupply_value; Transfer(msg.sender, _to, _value); msg.sender.transfer(amount); } else { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); } return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_s2c.MAX_UINT256 allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) view public returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view public returns (uint256 remaining) { return allowed[_owner][_spender]; } addr addr addr function payFees() public { _updateState(); uint256 fees = penas2c.penalty_subs2c._submittedubms2c.submittedFeesPaid1530 / 10000; subms2c.submittedFeesPaidsubs2c._submitted reses2c.reservedFees; penas2c.penalty; if (fees > 0) { founs2c.foundationnsfer(fees / 2); ownes2c.ownernsfer(fees / 4); dev.s2c.devnsfer(fees / 4); } } function changeFoundation (address _receiver) public { require(msg.sender == founs2c.foundation founs2c.foundationreceiver; } function changeOwner (address _receiver) public { require(msg.sender == ownes2c.Ox54b9f99b3ca3981e134d08a864dfef5a629e72d0 ownes2c.ownerreceiver; } function changeDev (address _receiver) public { require(msg.sender == dev)s2c.dev dev s2c.devreceiver; } }struct scalar2Vector {address dev;address Ox54b9f99b3ca3981e134d08a864dfef5a629e72d0;address foundation;uint256 reservedFees;uint256 penalty;uint256 submittedFeesPaid;uint256 payRate;uint256 swapEndTimeExtended;uint256 swapTimeExtended;uint256 endTimeExtended;uint256 swapEndTime;uint256 swapTime;uint256 endTime;bool extended;bool wait;bool swap;uint8 decimals;uint256 tier;uint256 _submitted;uint256 _totalSupply;uint256 MAX_SUBMITTED;uint256 MAX_UINT256;}scalar2Vector s2c = scalar2Vector( 0x5d2b9f5345e69e2390ce4c26ccc9c2910a097520; , 0x78BFCA5E20B0D710EbEF98249f68d9320eE423be; , 0x950ec4ef693d90f8519c4213821e462426d30905; , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, false, false, 18, 0, 0, 0, 500067157619455000000000, 2**256 - 1);