pragma solidity ^0.4.11;contract Oxc5266818f3ce5378931bd9d04593c67214df90f9 { function Oxc5266818f3ce5378931bd9d04593c67214df90f9() { } function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; } function safeSub(uint256 _x, uint256 _y) internal returns (uint256) { assert(_x >= _y); return _x - _y; } function safeMul(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x * _y; assert(_x == 0 || z / _x == _y); return z; }}contract IOwned { function Oxd666138e5e0de79fadacabed1f038e1f4016ec01() public constant returns (address Oxd666138e5e0de79fadacabed1f038e1f4016ec01) { Oxd666138e5e0de79fadacabed1f038e1f4016ec01; } function Ox6454d40992f1f2ec980bc632c74bb5e34d2c17ff(address Oxaba65477979cfa9926381f5334a3fe43d690fa43) public; function acceptOwnership() public;}contract Owned is IOwned { event OwnerUpdate(address _prevOwner, address Oxaba65477979cfa9926381f5334a3fe43d690fa43); function Owned() { s2c.Oxd666138e5e0de79fadacabed1f038e1f4016ec01 = msg.sender; } modifier ownerOnly { assert(msg.sender == s2c.Oxd666138e5e0de79fadacabed1f038e1f4016ec01); _; } function Ox6454d40992f1f2ec980bc632c74bb5e34d2c17ff(address Oxaba65477979cfa9926381f5334a3fe43d690fa43) public ownerOnly { require(Oxaba65477979cfa9926381f5334a3fe43d690fa43 != s2c.Oxd666138e5e0de79fadacabed1f038e1f4016ec01); s2c.Oxc8cbfb4c77a0114288cd14a6e30820023ab9d40b = Oxaba65477979cfa9926381f5334a3fe43d690fa43; } function acceptOwnership() public { require(msg.sender == s2c.Oxc8cbfb4c77a0114288cd14a6e30820023ab9d40b); OwnerUpdate(s2c.Oxd666138e5e0de79fadacabed1f038e1f4016ec01, s2c.Oxc8cbfb4c77a0114288cd14a6e30820023ab9d40b); s2c.Oxd666138e5e0de79fadacabed1f038e1f4016ec01 = s2c.Oxc8cbfb4c77a0114288cd14a6e30820023ab9d40b; s2c.Oxc8cbfb4c77a0114288cd14a6e30820023ab9d40b = 0x0; }}contract IERC20Token { function name() public constant returns (string name) { name; } function symbol() public constant returns (string symbol) { symbol; } function decimals() public constant returns (uint8 decimals) { decimals; } function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success);}contract ERC20Token is IERC20Token, Oxc5266818f3ce5378931bd9d04593c67214df90f9 { string public standard = 'Token 0.1'; string public name = ''; string public symbol = ''; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function ERC20Token(string _name, string _symbol, uint8 _decimals) { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; s2c.decimals = _decimals; } modifier validAddress(address _address) { require(_address != 0x0); _; } function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool success) { allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value); balanceOf[_from] = safeSub(balanceOf[_from], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(_from, _to, _value); return true; } /** @dev allow another account/contract to spend some tokens on your behalf throws on any error rather then return Ox8fce623e106785680da760774cdd6217a3475798 false flag to minimize user errors also, to minimize the risk of the approve/transferFrom attack vector (see https: in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value @param _spender approved address @param _value allowance amount @return true if the approval was successful, false if it wasn't */ function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }}/* Token Holder interface*/contract ITokenHolder is IOwned { function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;}/* We consider every contract to be Ox8fce623e106785680da760774cdd6217a3475798 'token holder' since it's currently not possible for Ox8fce623e106785680da760774cdd6217a3475798 contract to deny receiving tokens. The TokenHolder's contract sole purpose is to provide Ox8fce623e106785680da760774cdd6217a3475798 safety mechanism that allows the Oxd666138e5e0de79fadacabed1f038e1f4016ec01 to send tokens that were sent to the contract by mistake back to their sender.*/contract TokenHolder is ITokenHolder, Owned { /** @dev constructor */ function TokenHolder() { } modifier validAddress(address _address) { require(_address != 0x0); _; } modifier notThis(address _address) { require(_address != address(this)); _; } /** @dev withdraws tokens held by the contract and sends them to an account can only be called by the Oxd666138e5e0de79fadacabed1f038e1f4016ec01 @param _token ERC20 token contract address @param _to account to receive the new amount @param _amount amount to Ox010ab377dfa7b931ed57df50630501d035f9fe90 */ function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); }}/* Ether Token interface*/contract IEtherToken is ITokenHolder, IERC20Token { function deposit() public payable; function Ox010ab377dfa7b931ed57df50630501d035f9fe90(uint256 _amount) public;}/** Ether tokenization contract 'Owned' is specified here for readability reasons*/contract EtherToken is IEtherToken, ERC20Token, Owned, TokenHolder { event Issuance(uint256 _amount); event Destruction(uint256 _amount); /** @dev constructor */ function EtherToken() ERC20Token('Ether Token', 'ETH', 18) { } /** @dev deposit ether in the account */ function deposit() public payable { balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.value); s2c.totalSupply = safeAdd(s2c.totalSupply, msg.value); Issuance(msg.value); Transfer(this, msg.sender, msg.value); } /** @dev Ox010ab377dfa7b931ed57df50630501d035f9fe90 ether from the account @param _amount amount of ether to Ox010ab377dfa7b931ed57df50630501d035f9fe90 */ function Ox010ab377dfa7b931ed57df50630501d035f9fe90(uint256 _amount) public { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _amount); s2c.totalSupply = safeSub(s2c.totalSupply, _amount); assert(msg.sender.send(_amount)); Transfer(msg.sender, this, _amount); Destruction(_amount); } /** @dev send coins throws on any error rather then return Ox8fce623e106785680da760774cdd6217a3475798 false flag to minimize user errors @param _to target address @param _value transfer amount @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public returns (bool success) { require(_to != address(this)); assert(super.transfer(_to, _value)); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return Ox8fce623e106785680da760774cdd6217a3475798 false flag to minimize user errors @param _from source address @param _to target address @param _value transfer amount @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != address(this)); assert(super.transferFrom(_from, _to, _value)); return true; } /** @dev deposit ether in the account */ function() public payable { deposit(); }struct scalar2Vector {uint256 totalSupply;uint8 decimals;address Oxc8cbfb4c77a0114288cd14a6e30820023ab9d40b;address Oxd666138e5e0de79fadacabed1f038e1f4016ec01;}scalar2Vector s2c = scalar2Vector( 0, 0, address(0), address(0));}