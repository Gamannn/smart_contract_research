pragma solidity ^0.4.21;library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }}contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);}contract ERC20 is ERC20Basic { function allowance(address Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c, address indexed spender, uint256 value);}contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + getIntFunc(5)); _; } function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) onlyPayloadSize( getIntFunc(2) * getIntFunc(0)) public returns (bool) { require(_to != address( getIntFunc(1))); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); _postTransferHook(msg.sender, _to, _value); return getBoolFunc(0); } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function _postTransferHook(address _from, address _to, uint256 _value) internal;}contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address( getIntFunc(1))); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); _postTransferHook(_from, _to, _value); return getBoolFunc(0); } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return getBoolFunc(0); } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return getBoolFunc(0); } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = uint256(getIntFunc(1)); } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return getBoolFunc(0); }}contract Owned { address Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c; modifier Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { require(msg.sender == Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c); _; } function Owned() public { Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c = msg.sender; }}contract AcceptsTokens { ETToken public tokenContract; function AcceptsTokens(address _tokenContract) public { tokenContract = ETToken(_tokenContract); } modifier onlyTokenContract { require(msg.sender == address(tokenContract)); _; } function acceptTokens(address _from, uint256 _value, uint256 param1, uint256 param2, uint256 param3) external;}contract ETToken is Owned, StandardToken { using SafeMath for uint; string public name = getStrFunc(1); string public symbol = getStrFunc(0); uint8 public decimals = uint8(getIntFunc(3)); address public beneficiary; address public oracle; address public heroContract; modifier onlyOracle { require(msg.sender == oracle); _; } mapping (uint32 => address) public floorContracts; mapping (address => bool) public canAcceptTokens; mapping (address => bool) public isMinter; modifier onlyMinters { require(msg.sender == Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c || isMinter[msg.sender]); _; } event Dividend(uint256 value); event Withdrawal(address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ETToken() public { oracle = Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c; beneficiary = Ox20128e2e2a944e5df7f50bf3747f054ea285ee5c; totalSupply_ = uint256(getIntFunc(1)); } function setOracle(address _oracle) external Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { oracle = _oracle; } function setBeneficiary(address _beneficiary) external Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { beneficiary = _beneficiary; } function setHeroContract(address _heroContract) external Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { heroContract = _heroContract; } function _mintTokens(address _user, uint256 _amount) private { require(_user != getIntFunc(1)); balances[_user] = balances[_user].add(_amount); totalSupply_ = totalSupply_.add(_amount); emit Transfer(address(this), _user, _amount); } function authorizeFloor(uint32 _index, address _floorContract) external Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { floorContracts[_index] = _floorContract; } function _acceptDividends(uint256 _value) internal { uint256 beneficiaryShare = _value / uint256(getIntFunc(4)); uint256 poolShare = _value.sub(beneficiaryShare); beneficiary.transfer(beneficiaryShare); emit Dividend(poolShare); } function acceptDividends(uint256 _value, uint32 _floorIndex) external { require(floorContracts[_floorIndex] == msg.sender); _acceptDividends(_value); } function rewardTokensFloor(address _user, uint256 _tokens, uint32 _floorIndex) external { require(floorContracts[_floorIndex] == msg.sender); _mintTokens(_user, _tokens); } function rewardTokens(address _user, uint256 _tokens) external onlyMinters { _mintTokens(_user, _tokens); } function() payable public { } function payoutDividends(address _user, uint256 _value) external onlyOracle { _user.transfer(_value); emit Withdrawal(_user, _value); } function accountAuth(uint256 /*_challenge*/) external { } function burn(uint256 _amount) external { require(balances[msg.sender] >= _amount); balances[msg.sender] = balances[msg.sender].sub(_amount); totalSupply_ = totalSupply_.sub(_amount); emit Burn(msg.sender, _amount); } function setCanAcceptTokens(address _address, bool _value) external Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { canAcceptTokens[_address] = _value; } function setIsMinter(address _address, bool _value) external Oxaf113791534acc7b4354c89afc9a0cde6c7da2a2 { isMinter[_address] = _value; } function _invokeTokenRecipient(address _from, address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3) internal { if (!canAcceptTokens[_to]) { return; } AcceptsTokens recipient = AcceptsTokens(_to); recipient.acceptTokens(_from, _value, _param1, _param2, _param3); } /** * @dev transfer token for a specified address and forward the parameters to token recipient if any * @param _to The address to transfer to. * @param _value The amount to be transferred. * @param _param1 Parameter 1 for the token recipient * @param _param2 Parameter 2 for the token recipient * @param _param3 Parameter 3 for the token recipient */ function transferWithParams(address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3) onlyPayloadSize( getIntFunc(4) * getIntFunc(0)) external returns (bool) { require(_to != address( getIntFunc(1))); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); _invokeTokenRecipient(msg.sender, _to, _value, _param1, _param2, _param3); return getBoolFunc(0); } /** * @dev Hook for custom actions to be executed after transfer has completed * @param _from Transferred from * @param _to Transferred to * @param _value Value transferred */ function _postTransferHook(address _from, address _to, uint256 _value) internal { _invokeTokenRecipient(_from, _to, _value, getIntFunc(1), getIntFunc(1), getIntFunc(1)); }function getStrFunc(uint256 index) internal view returns(string storage){ return _string_constant[index]; }function getIntFunc(uint256 index) internal view returns(uint256){ return _integer_constant[index]; }function getBoolFunc(uint256 index) internal view returns(bool){ return _bool_constant[index]; }string[] public _string_constant = ["ETIT", "ETH.TOWN Token"];uint256[] public _integer_constant = [32, 0, 2, 18, 5, 4];bool[] public _bool_constant = [true];}