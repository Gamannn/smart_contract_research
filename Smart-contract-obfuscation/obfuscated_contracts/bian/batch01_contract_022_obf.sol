pragma solidity 0.4.24;library Address { function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > getIntFunc(8); }}contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);}contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address( getIntFunc(8))); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return getBoolFunc(0); } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }}library SafeERC20 { using SafeMath for uint256; using Address for address; function safeTransfer(IERC20 token, address to, uint256 value) internal { callOptionalReturn(token, abi.encodeWithSelector(bytes4( getIntFunc(0)), to, value)); } function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { callOptionalReturn(token, abi.encodeWithSelector(bytes4( getIntFunc(4)), from, to, value)); } function safeApprove(IERC20 token, address spender, uint256 value) internal { require((value == getIntFunc(8)) || (token.allowance(address(this), spender) == getIntFunc(8)), getStrFunc(1) ); callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); } function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { uint256 newAllowance = token.allowance(address(this), spender).add(value); callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance)); } function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { uint256 newAllowance = token.allowance(address(this), spender).sub(value); callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance)); } function callOptionalReturn(IERC20 token, bytes memory data) private { require(address(token).isContract(), getStrFunc(3)); bool success = address(token).call(data); require(success, getStrFunc(0)); }}interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address recipient, uint256 amount) external returns (bool); function allowance(address Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13, address spender) external view returns (uint256); function approve(address spender, uint256 amount) external returns (bool); /** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller's * allowance. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a `Transfer` event. */ function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); /** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ event Transfer(address indexed from, address indexed to, uint256 value); /** * @dev Emitted when the allowance of a `spender` for an `Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13` is set by * a call to `approve`. `value` is the new allowance. */ event Approval(address indexed Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13, address indexed spender, uint256 value);}/** * @title SafeMath * @dev Math operations with safety checks that throw on error */library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }}/** * @title Ownable * @dev The Ownable contract has an Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13 address, and provides basic authorization control * functions, this simplifies the implementation of "user permissions". */contract Ownable { address public Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13` of the contract to the sender * account. */ function Ownable() public { Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13 = msg.sender; } /** * @dev Throws if called by any account other than the Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13. */ modifier Ox7aca72462811c9f11b3ec8f18688f8c7d2e8e7f9() { require(msg.sender == Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13); _; } /** * @dev Allows the current Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13 to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public Ox7aca72462811c9f11b3ec8f18688f8c7d2e8e7f9 { require(newOwner != address( getIntFunc(8))); OwnershipTransferred(Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13, newOwner); Oxd9089fdb8e8a1ac19adcd5fe0f36321e15579e13 = newOwner; }}/* Copyright Ethfinex Inc 2018 Licensed under the Apache License, Version 2.0 http:*/contract WrapperLockEth is BasicToken, Ownable { using SafeERC20 for IERC20; using SafeMath for uint256; address public TRANSFER_PROXY_VEFX = getAddrFunc(0); address public TRANSFER_PROXY_V2 = address(); mapping (address => bool) public isSigner; string public name; string public symbol; uint public decimals; address public originalToken = address(getIntFunc(8)); mapping (address => uint) public depositLock; mapping (address => uint256) public balances; constructor(string _name, string _symbol, uint _decimals ) Ownable() { name = _name; symbol = _symbol; decimals = _decimals; isSigner[msg.sender] = getBoolFunc(0); } function deposit(uint _value, uint _forTime) public payable returns (bool success) { require(_forTime >= getIntFunc(3)); require(now + _forTime * getIntFunc(2) >= depositLock[msg.sender]); balances[msg.sender] = balances[msg.sender].add(msg.value); totalSupply_ = totalSupply_.add(msg.value); depositLock[msg.sender] = now + _forTime * uint256(getIntFunc(2)); return getBoolFunc(0); } function Oxcec0b730b1610bd5180c6ba4be31db32aa75eebd( uint _value, uint8 v, bytes32 r, bytes32 s, uint signatureValidUntilBlock ) public returns (bool) { require(balanceOf(msg.sender) >= _value); if (now > depositLock[msg.sender]) { balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply_ = totalSupply_.sub(_value); msg.sender.transfer(_value); } else { require(block.number < signatureValidUntilBlock); require(isValidSignature(keccak256(msg.sender, address(this), signatureValidUntilBlock), v, r, s)); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply_ = totalSupply_.sub(_value); depositLock[msg.sender] = uint256(getIntFunc(8)); msg.sender.transfer(_value); } return getBoolFunc(0); } function withdrawDifferentToken(address _differentToken) public Ox7aca72462811c9f11b3ec8f18688f8c7d2e8e7f9 returns (bool) { require(_differentToken != originalToken); require(IERC20(_differentToken).balanceOf(address(this)) > getIntFunc(8)); IERC20(_differentToken).safeTransfer(msg.sender, IERC20(_differentToken).balanceOf(address(this))); return getBoolFunc(0); } function transfer(address _to, uint256 _value) public returns (bool) { return getBoolFunc(1); } function transferFrom(address _from, address _to, uint _value) public { require(isSigner[_to] || isSigner[_from]); assert(msg.sender == TRANSFER_PROXY_VEFX || msg.sender == TRANSFER_PROXY_V2); balances[_to] = balances[_to].add(_value); depositLock[_to] = depositLock[_to] > now ? depositLock[_to] : now + uint256(getIntFunc(2)); balances[_from] = balances[_from].sub(_value); Transfer(_from, _to, _value); } function allowance(address _owner, address _spender) public constant returns (uint) { if (_spender == TRANSFER_PROXY_VEFX || _spender == TRANSFER_PROXY_V2) { return getIntFunc(1)** getIntFunc(7) - getIntFunc(3); } } function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; } function isValidSignature( bytes32 hash, uint8 v, bytes32 r, bytes32 s) public constant returns (bool) { return isSigner[ecrecover( keccak256( getStrFunc(2), hash), v, r, s )]; } function addSigner(address _newSigner) public { require(isSigner[msg.sender]); isSigner[_newSigner] = getBoolFunc(0); } function keccak(address _sender, address _wrapper, uint _validTill) public pure returns(bytes32) { return keccak256(_sender, _wrapper, _validTill); }function getIntFunc(uint256 index) internal view returns(uint256){ return _integer_constant[index]; }function getStrFunc(uint256 index) internal view returns(string storage){ return _string_constant[index]; }function getBoolFunc(uint256 index) internal view returns(bool){ return _bool_constant[index]; }function getAddrFunc(uint256 index) internal view returns(address payable){ return _address_constant[index]; }uint256[] public _integer_constant = [2835717307, 2, 3600, 1, 599290589, 8557...(40, 256, 0];string[] public _string_constant = ["SafeERC20: low-level call failed", "SafeERC20: approve from non-zero to non-zero allowance", "Ethereum Signed Message:32", "SafeERC20: call to non-contract"];bool[] public _bool_constant = [true, false];address payable[] public _address_constant = [0xdcDb42C9a256690bd153A7B409751ADFC8Dd5851];}