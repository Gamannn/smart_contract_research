pragma solidity ^0.5.1;interface IEthPool { function deposit(address _receiver) external payable; function Ox7b41cc1091760fda46adaeafb73ae8b37e6f44e1(uint _value) external; function approve(address _spender, uint _value) external returns (bool); function transferFrom(address _from, address payable _to, uint _value) external returns (bool); function transferToCelerWallet(address _from, address _walletAddr, bytes32 _walletId, uint _value) external returns (bool); function increaseAllowance(address _spender, uint _addedValue) external returns (bool); function decreaseAllowance(address _spender, uint _subtractedValue) external returns (bool); function balanceOf(address _owner) external view returns (uint); function allowance(address _owner, address _spender) external view returns (uint); event Deposit(address indexed receiver, uint value); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed Ox02c6809dcddcb7d0e4146f3010d4e381be84ceea, address indexed spender, uint value);}pragma solidity ^0.5.1;interface ICelerWallet { function create(address[] calldata _owners, address _operator, bytes32 _nonce) external returns(bytes32); function depositETH(bytes32 _walletId) external payable; function depositERC20(bytes32 _walletId, address _tokenAddress, uint _amount) external; function Ox7b41cc1091760fda46adaeafb73ae8b37e6f44e1(bytes32 _walletId, address _tokenAddress, address _receiver, uint _amount) external; function transferToWallet(bytes32 _fromWalletId, bytes32 _toWalletId, address _tokenAddress, address _receiver, uint _amount) external; function transferOperatorship(bytes32 _walletId, address _newOperator) external; function proposeNewOperator(bytes32 _walletId, address _newOperator) external; function drainToken(address _tokenAddress, address _receiver, uint _amount) external; function getWalletOwners(bytes32 _walletId) external view returns(address[] memory); function getOperator(bytes32 _walletId) external view returns(address); function getBalance(bytes32 _walletId, address _tokenAddress) external view returns(uint); function getProposedNewOperator(bytes32 _walletId) external view returns(address); function getProposalVote(bytes32 _walletId, address _owner) external view returns(bool); event CreateWallet(bytes32 indexed walletId, address[] indexed owners, address indexed operator); event DepositToWallet(bytes32 indexed walletId, address indexed tokenAddress, uint amount); event WithdrawFromWallet(bytes32 indexed walletId, address indexed tokenAddress, address indexed receiver, uint amount); event TransferToWallet(bytes32 indexed fromWalletId, bytes32 indexed toWalletId, address indexed tokenAddress, address receiver, uint amount); event ChangeOperator(bytes32 indexed walletId, address indexed oldOperator, address indexed newOperator); event ProposeNewOperator(bytes32 indexed walletId, address indexed newOperator, address indexed proposer); event DrainToken(address indexed tokenAddress, address indexed receiver, uint amount);}pragma solidity ^0.5.0;library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); uint256 c = a - b; return c; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; }}pragma solidity ^0.5.1; contract EthPool is IEthPool { using SafeMath for uint; mapping (address => uint) private balances; mapping (address => mapping (address => uint)) private allowed; string public constant name = getStrFunc(3); string public constant symbol = getStrFunc(0); uint8 public constant decimals = uint8(getIntFunc(0)); function deposit(address _receiver) public payable { require(_receiver != address( getIntFunc(1)), getStrFunc(1)); balances[_receiver] = balances[_receiver].add(msg.value); emit Deposit(_receiver, msg.value); } function Ox7b41cc1091760fda46adaeafb73ae8b37e6f44e1(uint _value) public { _transfer(msg.sender, msg.sender, _value); } function approve(address _spender, uint _value) public returns (bool) { require(_spender != address( getIntFunc(1)), getStrFunc(4)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return getBoolFunc(0); } function transferFrom(address _from, address payable _to, uint _value) public returns (bool) { allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Approval(_from, msg.sender, allowed[_from][msg.sender]); _transfer(_from, _to, _value); return getBoolFunc(0); } function transferToCelerWallet( address _from, address _walletAddr, bytes32 _walletId, uint _value ) external returns (bool) { allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Approval(_from, msg.sender, allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); emit Transfer(_from, _walletAddr, _value); ICelerWallet wallet = ICelerWallet(_walletAddr); wallet.depositETH.value(_value)(_walletId); return getBoolFunc(0); } function increaseAllowance(address _spender, uint _addedValue) public returns (bool) { require(_spender != address( getIntFunc(1)), getStrFunc(4)); allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return getBoolFunc(0); } /** * @notice Decrease the amount of ETH that an Ox02c6809dcddcb7d0e4146f3010d4e381be84ceea allowed to a spender. * @dev approve should be called when allowed[msg.sender][spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * Emits an Approval event. * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of ETH to decrease the allowance by. */ function decreaseAllowance(address _spender, uint _subtractedValue) public returns (bool) { require(_spender != address( getIntFunc(1)), getStrFunc(4)); allowed[msg.sender][_spender] = allowed[msg.sender][_spender].sub(_subtractedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return getBoolFunc(0); } /** * @notice Gets the balance of the specified address. * @param _owner The address to query the balance of. * @return An uint representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint) { return balances[_owner]; } /** * @notice Function to check the amount of ETH that an Ox02c6809dcddcb7d0e4146f3010d4e381be84ceea allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint specifying the amount of ETH still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint) { return allowed[_owner][_spender]; } /** * @notice Transfer ETH for a specified addresses * @param _from The address to transfer from. * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function _transfer(address _from, address payable _to, uint _value) internal { require(_to != address( getIntFunc(1)), getStrFunc(2)); balances[_from] = balances[_from].sub(_value); emit Transfer(_from, _to, _value); _to.transfer(_value); }function getBoolFunc(uint256 index) internal view returns(bool){ return _bool_constant[index]; }function getIntFunc(uint256 index) internal view returns(uint256){ return _integer_constant[index]; }function getStrFunc(uint256 index) internal view returns(string storage){ return _string_constant[index]; }bool[] public _bool_constant = [true];uint256[] public _integer_constant = [18, 0];string[] public _string_constant = ["EthIP", "Receiver address is 0", "To address is 0", "EthInPool", "Spender address is 0"];}