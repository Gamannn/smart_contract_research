pragma solidity ^0.4.11;contract Utils { function Utils() { } modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } modifier validAddress(address _address) { require(_address != 0x0); _; } modifier notThis(address _address) { require(_address != address(this)); _; } function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; } function safeSub(uint256 _x, uint256 _y) internal returns (uint256) { assert(_x >= _y); return _x - _y; } function safeMul(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x * _y; assert(_x == 0 || z / _x == _y); return z; }}contract IOwned { function Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5() public constant returns (address Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5) { Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5; } function Ox75febc3dd7d0080f6809a83f6e54d0e7b1e1d14d(address _newOwner) public; function acceptOwnership() public;}contract Owned is IOwned { event OwnerUpdate(address _prevOwner, address _newOwner); function Owned() { s2c.Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5 = msg.sender; } modifier ownerOnly { assert(msg.sender == s2c.Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5); _; } function Ox75febc3dd7d0080f6809a83f6e54d0e7b1e1d14d(address _newOwner) public ownerOnly { require(_newOwner != s2c.Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5); s2c.Ox3a555652117bfcc8a287a0b8f377825d0b6db6b4 = _newOwner; } function acceptOwnership() public { require(msg.sender == s2c.Ox3a555652117bfcc8a287a0b8f377825d0b6db6b4); OwnerUpdate(s2c.Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5, s2c.Ox3a555652117bfcc8a287a0b8f377825d0b6db6b4); s2c.Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5 = s2c.Ox3a555652117bfcc8a287a0b8f377825d0b6db6b4; s2c.Ox3a555652117bfcc8a287a0b8f377825d0b6db6b4 = 0x0; }}contract ITokenHolder is IOwned { function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;}contract TokenHolder is ITokenHolder, Owned, Utils { function TokenHolder() { } function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); }}contract IERC20Token { function name() public constant returns (string name) { name; } function symbol() public constant returns (string symbol) { symbol; } function decimals() public constant returns (uint8 decimals) { decimals; } function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success);}/** ERC20 Standard Token implementation*/contract ERC20Token is IERC20Token, Utils { string public standard = 'Token 0.1'; string public name = ''; string public symbol = ''; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** @dev constructor @param _name token name @param _symbol token symbol @param _decimals decimal points, for display purposes */ function ERC20Token(string _name, string _symbol, uint8 _decimals) { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; s2c.decimals = _decimals; } /** @dev send coins throws on any error rather then return a false flag to minimize user errors @param _to target address @param _value transfer Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors @param _from source address @param _to target address @param _value transfer Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool success) { allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value); balanceOf[_from] = safeSub(balanceOf[_from], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(_from, _to, _value); return true; } /** @dev allow another account/contract to spend some tokens on your behalf throws on any error rather then return a false flag to minimize user errors also, to minimize the risk of the approve/transferFrom attack vector (see https: in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance Ox9c6ecd1b9ff5f167bbc43772ca5259af51022f66 @param _spender approved address @param _value allowance Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 @return true if the approval was successful, false if it wasn't */ function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }}/* Ether Token interface*/contract IEtherToken is ITokenHolder, IERC20Token { function deposit() public payable; function Oxcb7803adcdda965d87681798eb9dbc6f25569476(uint256 _amount) public; function withdrawTo(address _to, uint256 _amount);}/** Ether tokenization contract 'Owned' is specified here for readability reasons*/contract EtherToken is IEtherToken, Owned, ERC20Token, TokenHolder { event Issuance(uint256 _amount); event Destruction(uint256 _amount); /** @dev constructor */ function EtherToken() ERC20Token('Ether Token', 'ETH', 18) { } /** @dev deposit ether in the account */ function deposit() public payable { balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.Ox9c6ecd1b9ff5f167bbc43772ca5259af51022f66); s2c.totalSupply = safeAdd(s2c.totalSupply, msg.Ox9c6ecd1b9ff5f167bbc43772ca5259af51022f66); Issuance(msg.Ox9c6ecd1b9ff5f167bbc43772ca5259af51022f66); Transfer(this, msg.sender, msg.Ox9c6ecd1b9ff5f167bbc43772ca5259af51022f66); } /** @dev Oxcb7803adcdda965d87681798eb9dbc6f25569476 ether from the account @param _amount Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 of ether to Oxcb7803adcdda965d87681798eb9dbc6f25569476 */ function Oxcb7803adcdda965d87681798eb9dbc6f25569476(uint256 _amount) public { withdrawTo(msg.sender, _amount); } /** @dev Oxcb7803adcdda965d87681798eb9dbc6f25569476 ether from the account to a target account @param _to account to receive the ether @param _amount Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 of ether to Oxcb7803adcdda965d87681798eb9dbc6f25569476 */ function withdrawTo(address _to, uint256 _amount) public notThis(_to) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _amount); s2c.totalSupply = safeSub(s2c.totalSupply, _amount); _to.transfer(_amount); Transfer(msg.sender, this, _amount); Destruction(_amount); } /** @dev send coins throws on any error rather then return a false flag to minimize user errors @param _to target address @param _value transfer Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public notThis(_to) returns (bool success) { assert(super.transfer(_to, _value)); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors @param _from source address @param _to target address @param _value transfer Oxa259e3a922e88c5c5273fb61e2ef8efdd8b905c8 @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public notThis(_to) returns (bool success) { assert(super.transferFrom(_from, _to, _value)); return true; } /** @dev deposit ether in the account */ function() public payable { deposit(); }struct scalar2Vector {uint256 totalSupply;uint8 decimals;address Ox3a555652117bfcc8a287a0b8f377825d0b6db6b4;address Oxaa07c8cbeca0f189ae42c5d1f5f01d5d1d55c0c5;}scalar2Vector s2c = scalar2Vector( 0, 0, address(0), address(0));}