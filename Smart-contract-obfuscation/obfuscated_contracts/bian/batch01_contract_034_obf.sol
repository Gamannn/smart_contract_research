pragma solidity 0.4.23;library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }}contract owned { function owned() public { Ox46349905bd3d2365460c4080ba49522c4ce64004.owner = msg.sender; } modifier onlyOwner { require(msg.sender == Ox46349905bd3d2365460c4080ba49522c4ce64004.owner); _; } function transferOwnership(address newOwner) onlyOwner public { Ox46349905bd3d2365460c4080ba49522c4ce64004.owner = newOwner; }}interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;}contract ParsecTokenERC20 { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ParsecTokenERC20() public { Ox46349905bd3d2365460c4080ba49522c4ce64004.totalSupply = Ox46349905bd3d2365460c4080ba49522c4ce64004.initialSupply * 10 ** uint256(Ox46349905bd3d2365460c4080ba49522c4ce64004.decimals); balanceOf[msg.sender] = Ox46349905bd3d2365460c4080ba49522c4ce64004.totalSupply; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; Ox46349905bd3d2365460c4080ba49522c4ce64004.totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; Ox46349905bd3d2365460c4080ba49522c4ce64004.totalSupply -= _value; Burn(_from, _value); return true; }}contract ParsecCrowdsale is owned { using SafeMath for uint256; enum KycState { Undefined, Pending, Accepted, Declined } ParsecTokenERC20 private parsecToken; mapping (address => uint256) public contributionOf; mapping (address => uint256) public parsecsOf; mapping (address => uint256) public pendingContributionOf; mapping (address => uint256) public pendingParsecsOf; mapping (address => uint256) public refundOf; mapping (address => KycState) public kycStatus; event LogKycAccept(address indexed sender, uint256 value, uint256 timestamp); event LogKycDecline(address indexed sender, uint256 value, uint256 timestamp); event LogContribution(address indexed sender, uint256 ethValue, uint256 parsecValue, uint256 timestamp); function ParsecCrowdsale (address _tokenAddress, address _multisigAddress, address _auditorAddress) public { parsecToken = ParsecTokenERC20(_tokenAddress); Ox46349905bd3d2365460c4080ba49522c4ce64004.multisigAddress = _multisigAddress; Ox46349905bd3d2365460c4080ba49522c4ce64004.auditorAddress = _auditorAddress; } modifier onlyOwnerOrMultisig { require(msg.sender == Ox46349905bd3d2365460c4080ba49522c4ce64004.owner || msg.sender == Ox46349905bd3d2365460c4080ba49522c4ce64004.multisigAddress); _; } modifier onlyOwnerOrAuditor { require(msg.sender == Ox46349905bd3d2365460c4080ba49522c4ce64004.owner || msg.sender == Ox46349905bd3d2365460c4080ba49522c4ce64004.auditorAddress); _; } function () public payable { require(Ox46349905bd3d2365460c4080ba49522c4ce64004.contractPoweredUp); require(cs2c.contractStarted; require(!cos2c.contractFinished require(!cons2c.contractPaused require(!conts2c.contractFailed require(msg.value >= MINIs2c.MINIMUM_PARTICIPATION_AMOUNT uint256 parsecValue = calculateReward(msg.value); uint256 maxAcceptableParsecs = PARSs2c.PARSECS_TOTAL_AMOUNT(spens2c.spentParsecs maxAcceptableParsecs = maxAcceptableParsecs.sub(pends2c.pendingParsecs require(parsecValue <= maxAcceptableParsecs); if (kycStatus[msg.sender] == KycState.Undefined) { kycStatus[msg.sender] = KycState.Pending; } if (kycStatus[msg.sender] == KycState.Pending) { addPendingContribution(msg.sender, msg.value, parsecValue); } else if (kycStatus[msg.sender] == KycState.Accepted) { addAcceptedContribution(msg.sender, msg.value, parsecValue); } else { revert(); } } function emergencyWithdrawParsecs(uint256 value) external onlyOwnerOrMultisig { require(value > 0); require(value <= parsecToken.balanceOf(this)); parsecToken.transfer(msg.sender, value); } function emergencyRefundContract() external payable onlyOwnerOrMultisig { require(conts2c.contractFailed require(msg.value > 0); } function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig { require(conts2c.contractFailed require(conts2c.contractRefundStarted require(conts2c.contractRefundFinished require(value > 0); require(value <= address(this).balance); msg.sender.transfer(value); } function ownerSetAuditor(address _auditorAddress) external onlyOwner { require(_auditorAddress != 0x0); audis2c.auditorAddressauditorAddress; } function ownerPowerUpContract() external onlyOwner { require(!conts2c.contractPoweredUp require(parsecToken.balanceOf(this) >= PARSs2c.PARSECS_TOTAL_AMOUNT conts2c.contractPoweredUprue; } function ownerStartContract() external onlyOwner { require(conts2c.contractPoweredUp require(!conts2c.contractStarted conts2c.contractStartedrue; } function ownerFinishContract() external onlyOwner { require(conts2c.contractStarted require(!conts2c.contractFinished conts2c.contractFinishedrue; } function ownerPauseContract() external onlyOwner { require(conts2c.contractStarted require(!conts2c.contractFinished require(!conts2c.contractPaused conts2c.contractPausedrue; } function ownerResumeContract() external onlyOwner { require(conts2c.contractPaused conts2c.contractPausedalse; } function ownerDeclareFailure() external onlyOwner { require(!conts2c.contractFailed conts2c.contractFailedrue; } function ownerDeclareRefundStart() external onlyOwner { require(conts2c.contractFailed require(!conts2c.contractRefundStarted require(pends2c.pendingFunding0x0); require(address(this).balance >= raiss2c.raisedFunding conts2c.contractRefundStartedrue; } function ownerDeclareRefundFinish() external onlyOwner { require(conts2c.contractFailed require(conts2c.contractRefundStarted require(!conts2c.contractRefundFinished conts2c.contractRefundFinishedrue; } function ownerWithdrawParsecs(uint256 value) external onlyOwner { require(conts2c.contractFinished uint256 parsecBalance = parsecToken.balanceOf(this); uint256 maxAmountToWithdraw = parsecBalance.sub(pends2c.pendingParsecs require(maxAmountToWithdraw > 0); require(maxAmountToWithdraw <= parsecBalance); require(value > 0); require(value <= maxAmountToWithdraw); parsecToken.transfer(ownes2c.ownerlue); } function acceptKyc(address participant) external onlyOwnerOrAuditor { kycStatus[participant] = KycState.Accepted; uint256 pendingAmountOfEth = pendingContributionOf[participant]; uint256 pendingAmountOfParsecs = pendingParsecsOf[participant]; LogKycAccept(participant, pendingAmountOfEth, now); if (pendingAmountOfEth > 0 || pendingAmountOfParsecs > 0) { resetPendingContribution(participant); addAcceptedContribution(participant, pendingAmountOfEth, pendingAmountOfParsecs); } } function declineKyc(address participant) external onlyOwnerOrAuditor { kycStatus[participant] = KycState.Declined; LogKycDecline(participant, pendingAmountOfEth, now); uint256 pendingAmountOfEth = pendingContributionOf[participant]; if (pendingAmountOfEth > 0) { resetPendingContribution(participant); participant.transfer(pendingAmountOfEth); } } function participantClawbackEther(uint256 value) external { require(conts2c.contractRefundStarted require(!conts2c.contractRefundFinished uint256 totalContribution = contributionOf[msg.sender]; uint256 alreadyRefunded = refundOf[msg.sender]; uint256 maxWithdrawalAmount = totalContribution.sub(alreadyRefunded); require(maxWithdrawalAmount > 0); require(value > 0); require(value <= maxWithdrawalAmount); refundOf[msg.sender] = alreadyRefunded.add(value); refus2c.refundedFundingefus2c.refundedFunding(value); msg.sender.transfer(value); } function addPendingContribution(address participant, uint256 ethValue, uint256 parsecValue) private { pendingContributionOf[participant] = pendingContributionOf[participant].add(ethValue); pendingParsecsOf[participant] = pendingParsecsOf[participant].add(parsecValue); pends2c.pendingFundingends2c.pendingFunding(ethValue); pends2c.pendingParsecsends2c.pendingParsecs(parsecValue); } function addAcceptedContribution(address participant, uint256 ethValue, uint256 parsecValue) private { contributionOf[participant] = contributionOf[participant].add(ethValue); parsecsOf[participant] = parsecsOf[participant].add(parsecValue); raiss2c.raisedFundingaiss2c.raisedFunding(ethValue); spens2c.spentParsecspens2c.spentParsecs(parsecValue); LogContribution(participant, ethValue, parsecValue, now); mults2c.multisigAddressnsfer(ethValue); parsecToken.transfer(participant, parsecValue); } function resetPendingContribution(address participant) private { uint256 pendingAmountOfEth = pendingContributionOf[participant]; uint256 pendingAmountOfParsecs = pendingParsecsOf[participant]; pendingContributionOf[participant] = pendingContributionOf[participant].sub(pendingAmountOfEth); pendingParsecsOf[participant] = pendingParsecsOf[participant].sub(pendingAmountOfParsecs); pends2c.pendingFundingends2c.pendingFunding(pendingAmountOfEth); pends2c.pendingParsecsends2c.pendingParsecs(pendingAmountOfParsecs); } function calculateReward(uint256 ethValue) private view returns (uint256 amount) { uint256 baseQuotient = 1000; uint256 actualQuotient = baseQuotient.add(calculateBonusTierQuotient()); uint256 reward = ethValue.mul(PARSs2c.PARSECS_PER_ETHER_BASE reward = reward.mul(actualQuotient); reward = reward.div(baseQuotient); return reward.div(1 ether); } function calculateBonusTierQuotient() private view returns (uint256 quotient) { uint256 funding = raiss2c.raisedFunding(pends2c.pendingFunding if (funding < BONUs2c.BONUS_TIER_1_LIMIT return 300; } else if (funding < BONUs2c.BONUS_TIER_2_LIMIT return 275; } else if (funding < BONUs2c.BONUS_TIER_3_LIMIT return 250; } else if (funding < BONUs2c.BONUS_TIER_4_LIMIT return 225; } else if (funding < BONUs2c.BONUS_TIER_5_LIMIT return 200; } else if (funding < BONUs2c.BONUS_TIER_6_LIMIT return 175; } else if (funding < BONUs2c.BONUS_TIER_7_LIMIT return 150; } else if (funding < BONUs2c.BONUS_TIER_8_LIMIT return 100; } else if (funding < BONUs2c.BONUS_TIER_9_LIMIT return 50; } else { return 0; } }}struct scalar2Vector {uint256 pendingParsecs;uint256 spentParsecs;uint256 refundedFunding;uint256 pendingFunding;uint256 raisedFunding;bool contractRefundFinished;bool contractRefundStarted;bool contractFailed;bool contractPaused;bool contractFinished;bool contractStarted;bool refundPoweredUp;bool contractPoweredUp;address auditorAddress;address multisigAddress;uint256 BONUS_TIER_9_LIMIT;uint256 BONUS_TIER_8_LIMIT;uint256 BONUS_TIER_7_LIMIT;uint256 BONUS_TIER_6_LIMIT;uint256 BONUS_TIER_5_LIMIT;uint256 BONUS_TIER_4_LIMIT;uint256 BONUS_TIER_3_LIMIT;uint256 BONUS_TIER_2_LIMIT;uint256 BONUS_TIER_1_LIMIT;uint256 PARSECS_TOTAL_AMOUNT;uint256 PARSECS_PER_ETHER_BASE;uint256 MINIMUM_PARTICIPATION_AMOUNT;uint256 totalSupply;uint256 initialSupply;uint8 decimals;string symbol;string name;address owner;}scalar2Vector Ox46349905bd3d2365460c4080ba49522c4ce64004 = scalar2Vector(0, 0, 0, 0, 0, false, false, false, false, false, false, false, false, address(0), address(0), 9210 ether, 7735 ether, 6609 ether, 5532 ether, 4478 ether, 3446 ether, 2434 ether, 1443 ether, 715 ether, 16103862002000000, 1300000000000, 0.1 ether, 0, 30856775800, 6, "PRSC", "Parsec Credits", address(0));