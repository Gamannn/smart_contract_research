pragma solidity ^0.6.6;library Address { function isContract(address account) internal view returns (bool) { bytes32 codehash; bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; assembly { codehash := extcodehash(account) } return (codehash != accountHash && codehash != 0x0); } function sendValue(address payable recipient, uint256 amount) internal { require(address(this).balance >= amount, "Address: insufficient balance"); (bool success, ) = recipient.call{ value: amount }(""); require(success, "Address: unable to send value, recipient may have reverted"); } }library Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a { function Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1) internal pure returns (uint256) { uint256 Ox81f92ef40f1150403544f7a0768565dbe57e6e38 = Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f + Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1; require(Ox81f92ef40f1150403544f7a0768565dbe57e6e38 >= Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, "Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a: addition overflow"); return Ox81f92ef40f1150403544f7a0768565dbe57e6e38; } function Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1) internal pure returns (uint256) { return Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, "Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a: subtraction overflow"); } function Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, string memory errorMessage) internal pure returns (uint256) { require(Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1 <= Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, errorMessage); uint256 Ox81f92ef40f1150403544f7a0768565dbe57e6e38 = Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f - Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1; return Ox81f92ef40f1150403544f7a0768565dbe57e6e38; } function Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1) internal pure returns (uint256) { if (Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f == 0) { return 0; } uint256 Ox81f92ef40f1150403544f7a0768565dbe57e6e38 = Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f * Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1; require(Ox81f92ef40f1150403544f7a0768565dbe57e6e38 / Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f == Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, "Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a: multiplication overflow"); return Ox81f92ef40f1150403544f7a0768565dbe57e6e38; } function Ox420868c6d09e34f8bc34563a8caeaf95c512f228(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1) internal pure returns (uint256) { return Ox420868c6d09e34f8bc34563a8caeaf95c512f228(Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, "Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a: division by zero"); } function Ox420868c6d09e34f8bc34563a8caeaf95c512f228(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, string memory errorMessage) internal pure returns (uint256) { require(Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1 > 0, errorMessage); uint256 Ox81f92ef40f1150403544f7a0768565dbe57e6e38 = Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f / Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1; return Ox81f92ef40f1150403544f7a0768565dbe57e6e38; } function mod(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1) internal pure returns (uint256) { return mod(Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, "Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a: modulo by zero"); } function mod(uint256 Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f, uint256 Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1, string memory errorMessage) internal pure returns (uint256) { require(Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1 != 0, errorMessage); return Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f % Ox5af7808e5a867414ad34b51a1f953ebc77edd6a1; } }interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function Ox00f04898934cf24a689df681812ceae7f0938a54(address recipient, uint256 amount) external returns (bool); function allowance(address Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, address spender) external view returns (uint256); function approve(address spender, uint256 amount) external returns (bool); /** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller's * allowance. * * Returns Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f boolean value indicating whether the operation succeeded. * * Emits Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f {Transfer} event. */ function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); /** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ event Transfer(address indexed from, address indexed to, uint256 value); /** * @dev Emitted when the allowance of Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f `spender` for an `Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c` is set by * Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f call to {approve}. `value` is the new allowance. */ event Approval(address indexed Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, address indexed spender, uint256 value); }interface AggregatorInterface { function latestAnswer() external view returns (int256); function latestTimestamp() external view returns (uint256); function latestRound() external view returns (uint256); function getAnswer(uint256 roundId) external view returns (int256); function getTimestamp(uint256 roundId) external view returns (uint256); event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);}interface IUniswapFactory { function getExchange(IERC20 token) external view returns (UniswapExchangeInterface exchange);}interface UniswapExchangeInterface { function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought); function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought); function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256 tokens_bought); function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256 eth_bought); }interface ILiquidityPool { event Withdraw(address indexed account, uint amount, uint writeAmount); event Provide (address indexed account, uint amount, uint writeAmount); function totalBalance() external view returns (uint amount); function lock(uint amount) external; function unlock(uint amount) external; function send(address payable account, uint amount) external;}interface IERCLiquidityPool is ILiquidityPool { function token() external view returns(IERC20);}interface ERC20Incorrect { function balanceOf(address who) external view returns (uint); function Ox00f04898934cf24a689df681812ceae7f0938a54(address to, uint value) external; function allowance(address Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, address spender) external view returns (uint); function transferFrom(address from, address to, uint value) external; function approve(address spender, uint value) external; event Approval(address indexed Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value);}interface SpreadLock { function highSpreadLockEnabled() external returns (bool);}contract Context { constructor () internal { } function _msgSender() internal view virtual returns (address payable) { return msg.sender; } function _msgData() internal view virtual returns (bytes memory) { this; return msg.data; }}contract ERC20 is Context, IERC20 { using Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a for uint256; using Address for address; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowances; /** * @dev Sets the values for {name} and {symbol}, initializes {decimals} with * Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f default value of 18. * * To select Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f different value for {decimals}, use {_setupDecimals}. * * All three of these values are immutable: they can only be set once during * construction. */ constructor (string memory name, string memory symbol) public { Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.Ox3548b198ab46dddeab577630e5e7e318c9abf469 = name; Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._symbol = symbol; Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._decimals = 18; } /** * @dev Returns the name of the token. */ function name() public view returns (string memory) { return Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.Ox3548b198ab46dddeab577630e5e7e318c9abf469; } /** * @dev Returns the symbol of the token, usually Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f shorter Ox1ef54897a7f8dd7d2a9efedb430898fde02a8ff3 of the * name. */ function symbol() public view returns (string memory) { return Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._symbol; } /** * @dev Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f balance of `505` tokens should * be displayed to Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-Ox00f04898934cf24a689df681812ceae7f0938a54}. */ function decimals() public view returns (uint8) { return Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._decimals; } /** * @dev See {IERC20-totalSupply}. */ function totalSupply() public view override returns (uint256) { return Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._totalSupply; } /** * @dev See {IERC20-balanceOf}. */ function balanceOf(address account) public view override returns (uint256) { return _balances[account]; } /** * @dev See {IERC20-Ox00f04898934cf24a689df681812ceae7f0938a54}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f balance of at least `amount`. */ function Ox00f04898934cf24a689df681812ceae7f0938a54(address recipient, uint256 amount) public virtual override returns (bool) { _transfer(_msgSender(), recipient, amount); return true; } /** * @dev See {IERC20-allowance}. */ function allowance(address Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, address spender) public view virtual override returns (uint256) { return _allowances[Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c][spender]; } /** * @dev See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address. */ function approve(address spender, uint256 amount) public virtual override returns (bool) { _approve(_msgSender(), spender, amount); return true; } /** * @dev See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f balance of at least `amount`. * - the caller must have allowance for ``sender``'s tokens of at least * `amount`. */ function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(amount, "ERC20: Ox00f04898934cf24a689df681812ceae7f0938a54 amount exceeds allowance")); return true; } /** * @dev Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. */ function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { _approve(_msgSender(), spender, _allowances[_msgSender()][spender].Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(addedValue)); return true; } /** * @dev Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`. */ function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) { _approve(_msgSender(), spender, _allowances[_msgSender()][spender].Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(subtractedValue, "ERC20: decreased allowance below zero")); return true; } /** * @dev Moves tokens `amount` from `sender` to `recipient`. * * This is internal function is equivalent to {Ox00f04898934cf24a689df681812ceae7f0938a54}, and can be used to * e.g. implement automatic token fees, slashing mechanisms, etc. * * Emits Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f {Transfer} event. * * Requirements: * * - `sender` cannot be the zero address. * - `recipient` cannot be the zero address. * - `sender` must have Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f balance of at least `amount`. */ function _transfer(address sender, address recipient, uint256 amount) internal virtual { require(sender != address(0), "ERC20: Ox00f04898934cf24a689df681812ceae7f0938a54 from the zero address"); require(recipient != address(0), "ERC20: Ox00f04898934cf24a689df681812ceae7f0938a54 to the zero address"); _beforeTokenTransfer(sender, recipient, amount); _balances[sender] = _balances[sender].Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(amount, "ERC20: Ox00f04898934cf24a689df681812ceae7f0938a54 amount exceeds balance"); _balances[recipient] = _balances[recipient].Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount); emit Transfer(sender, recipient, amount); } /** @dev Creates `amount` tokens and assigns them to `account`, increasing * the total supply. * * Emits Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address. */ function _mint(address account, uint256 amount) internal virtual { require(account != address(0), "ERC20: mint to the zero address"); _beforeTokenTransfer(address(0), account, amount); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._totalSupply = Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._totalSupply.Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount); _balances[account] = _balances[account].Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount); emit Transfer(address(0), account, amount); } /** * @dev Destroys `amount` tokens from `account`, reducing the * total supply. * * Emits Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f {Transfer} event with `to` set to the zero address. * * Requirements * * - `account` cannot be the zero address. * - `account` must have at least `amount` tokens. */ function _burn(address account, uint256 amount) internal virtual { require(account != address(0), "ERC20: Ox88e1c7cf66b44828577d676224c4934b7688d1ac from the zero address"); _beforeTokenTransfer(account, address(0), amount); _balances[account] = _balances[account].Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(amount, "ERC20: Ox88e1c7cf66b44828577d676224c4934b7688d1ac amount exceeds balance"); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._totalSupply = Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._totalSupply.Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(amount); emit Transfer(account, address(0), amount); } /** * @dev Sets `amount` as the allowance of `spender` over the `Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c`s tokens. * * This is internal function is equivalent to `approve`, and can be used to * e.g. set automatic allowances for certain subsystems, etc. * * Emits an {Approval} event. * * Requirements: * * - `Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c` cannot be the zero address. * - `spender` cannot be the zero address. */ function _approve(address Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, address spender, uint256 amount) internal virtual { require(Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c != address(0), "ERC20: approve from the zero address"); require(spender != address(0), "ERC20: approve to the zero address"); _allowances[Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c][spender] = amount; emit Approval(Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, spender, amount); } /** * @dev Sets {decimals} to Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f value other than the default one of 18. * * WARNING: This function should only be called from the constructor. Most * applications that interact with token contracts will not expect * {decimals} to ever change, and may work incorrectly if it does. */ function _setupDecimals(uint8 decimals_) internal { Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._decimals = decimals_; } /** * @dev Hook that is called before any Ox00f04898934cf24a689df681812ceae7f0938a54 of tokens. This includes * minting and burning. * * Calling conditions: * * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens * will be to transferred to `to`. * - when `from` is zero, `amount` tokens will be minted for `to`. * - when `to` is zero, `amount` of ``from``'s tokens will be burned. * - `from` and `to` are never both zero. * * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. */ function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }}contract Ownable is Context { event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev Initializes the contract setting the deployer as the initial Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. */ constructor () internal { address msgSender = _msgSender(); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner = msgSender; emit OwnershipTransferred(address(0), msgSender); } /** * @dev Returns the address of the current Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. */ function Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c() public view returns (address) { return Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner; } /** * @dev Throws if called by any account other than the Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. */ modifier onlyOwner() { require(Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner == _msgSender(), "Ownable: caller is not the Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c"); _; } /** * @dev Leaves the contract without Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. * * NOTE: Renouncing ownership will leave the contract without an Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c, * thereby removing any functionality that is only available to the Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. */ function renounceOwnership() public virtual onlyOwner { emit OwnershipTransferred(Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner, address(0)); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner = address(0); } /** * @dev Transfers ownership of the contract to Oxe0151eccb9b6a43d3e241fa28a9d9e5965bfe73f new account (`newOwner`). * Can only be called by the current Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c. */ function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), "Ownable: new Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c is the zero address"); emit OwnershipTransferred(Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner, newOwner); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198._owner = newOwner; }}contract HegicETHPool is ILiquidityPool, Ownable, ERC20("Hegic ETH LP Token", "writeETH"){ using Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a for uint256; receive() external payable {} function availableBalance() public view returns (uint balance) {balance = totalBalance().Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount);} function totalBalance() public override view returns (uint balance) { balance = address(this).balance;} function provide(uint minMint) public payable returns (uint mint) { mint = provide(); require(mint >= minMint, "Pool: Mint limit is too large"); } function provide() public payable returns (uint mint) { require(!SpreadLock(Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c()).highSpreadLockEnabled(), "Pool: Locked"); if(totalSupply().Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(totalBalance()) == 0) mint = msg.value.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(1000); else mint = msg.value.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(totalSupply()).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(totalBalance().Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(msg.value)); require(mint > 0, "Pool: Amount is too small"); emit Provide(msg.sender, msg.value, mint); _mint(msg.sender, mint); } function withdraw(uint amount, uint maxBurn) public returns (uint Ox88e1c7cf66b44828577d676224c4934b7688d1ac) { Ox88e1c7cf66b44828577d676224c4934b7688d1ac = withdraw(amount); require(Ox88e1c7cf66b44828577d676224c4934b7688d1ac <= maxBurn, "Pool: Burn limit is too small"); } function withdraw(uint amount) public returns (uint Ox88e1c7cf66b44828577d676224c4934b7688d1ac) { require(amount <= availableBalance(), "Pool: Insufficient unlocked funds"); Ox88e1c7cf66b44828577d676224c4934b7688d1ac = amount.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(totalSupply()).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(totalBalance()); require(Ox88e1c7cf66b44828577d676224c4934b7688d1ac <= balanceOf(msg.sender), "Pool: Amount is too large"); require(Ox88e1c7cf66b44828577d676224c4934b7688d1ac > 0, "Pool: Amount is too small"); _burn(msg.sender, Ox88e1c7cf66b44828577d676224c4934b7688d1ac); emit Withdraw(msg.sender, amount, Ox88e1c7cf66b44828577d676224c4934b7688d1ac); msg.sender.Ox00f04898934cf24a689df681812ceae7f0938a54(amount); } function shareOf(address user) public view returns (uint share){ if(totalBalance() > 0) share = totalBalance() .Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(balanceOf(user)) .Ox420868c6d09e34f8bc34563a8caeaf95c512f228(totalSupply()); } function lock(uint amount) public override onlyOwner { require( Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount.Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(10).Ox420868c6d09e34f8bc34563a8caeaf95c512f228( totalBalance() ) < 8, "Pool: Insufficient unlocked funds" ); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount = Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount.Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount); } function unlock(uint amount) public override onlyOwner { require(Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount >= amount, "Pool: Insufficient locked funds"); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount = Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount.Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(amount); } function send(address payable to, uint amount) public override onlyOwner { require(Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount >= amount, "Pool: Insufficient locked funds"); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.lockedAmount -= amount; to.Ox00f04898934cf24a689df681812ceae7f0938a54(amount); }}contract HegicERCPool is IERCLiquidityPool, Ownable, ERC20("Hegic DAI LP Token", "writeDAI"){ using Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a for uint256; IERC20 public override token; constructor(IERC20 _token) public { token = _token; } function availableBalance() public view returns (uint balance) {balance = totalBalance().Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(lockedAmount);} function totalBalance() public override view returns (uint balance) { balance = token.balanceOf(address(this));} function provide(uint amount, uint minMint) public returns (uint mint) { mint = provide(amount); require(mint >= minMint, "Pool: Mint limit is too large"); } function provide(uint amount) public returns (uint mint) { require(!SpreadLock(Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c()).highSpreadLockEnabled(), "Pool: Locked"); if(totalSupply().Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(totalBalance()) == 0) mint = amount.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(1000); else mint = amount.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(totalSupply()).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(totalBalance()); require(mint > 0, "Pool: Amount is too small"); emit Provide(msg.sender, amount, mint); require( token.transferFrom(msg.sender, address(this), amount), "Insufficient funds" ); _mint(msg.sender, mint); } function withdraw(uint amount, uint maxBurn) public returns (uint Ox88e1c7cf66b44828577d676224c4934b7688d1ac) { Ox88e1c7cf66b44828577d676224c4934b7688d1ac = withdraw(amount); require(Ox88e1c7cf66b44828577d676224c4934b7688d1ac <= maxBurn, "Pool: Burn limit is too small"); } function withdraw(uint amount) public returns (uint Ox88e1c7cf66b44828577d676224c4934b7688d1ac) { require(amount <= availableBalance(), "Pool: Insufficient unlocked funds"); Ox88e1c7cf66b44828577d676224c4934b7688d1ac = amount.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(totalSupply()).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(totalBalance()); require(Ox88e1c7cf66b44828577d676224c4934b7688d1ac <= balanceOf(msg.sender), "Pool: Amount is too large"); require(Ox88e1c7cf66b44828577d676224c4934b7688d1ac > 0, "Pool: Amount is too small"); _burn(msg.sender, Ox88e1c7cf66b44828577d676224c4934b7688d1ac); emit Withdraw(msg.sender, amount, Ox88e1c7cf66b44828577d676224c4934b7688d1ac); require( token.Ox00f04898934cf24a689df681812ceae7f0938a54(msg.sender, amount), "Insufficient funds" ); } function shareOf(address user) public view returns (uint share){ if(totalBalance() > 0) share = totalBalance() .Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(balanceOf(user)) .Ox420868c6d09e34f8bc34563a8caeaf95c512f228(totalSupply()); } function lock(uint amount) public override onlyOwner { require( lockedAmount.Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(10).Ox420868c6d09e34f8bc34563a8caeaf95c512f228( totalBalance() ) < 8, "Pool: Insufficient unlocked funds" ); lockedAmount = lockedAmount.Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(amount); } function unlock(uint amount) public override onlyOwner { require(lockedAmount >= amount, "Pool: Insufficient locked funds"); lockedAmount = lockedAmount.Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(amount); } function send(address payable to, uint amount) public override onlyOwner { require(lockedAmount >= amount, "Pool: Insufficient locked funds"); lockedAmount -= amount; require( token.Ox00f04898934cf24a689df681812ceae7f0938a54(to, amount), "Insufficient funds" ); }}abstract contract HegicOptions is Ownable, SpreadLock { using Ox3e2c5c8ff2d6076fe55f6f380cd48bb056f5758a for uint; Option[] public options; AggregatorInterface public priceProvider; IUniswapFactory public exchanges; IERC20 token; ILiquidityPool public pool; OptionType private optionType; constructor(IERC20 DAI, AggregatorInterface pp, IUniswapFactory ex, OptionType t) public { token = DAI; priceProvider = pp; exchanges = ex; optionType = t; } function setImpliedVolRate(uint value) public onlyOwner { require(value >= 10000, "ImpliedVolRate limit is too small"); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.impliedVolRate = value; } function setMaxSpread(uint value) public onlyOwner { require(value <= 95, "Spread limit is too large"); Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.maxSpread = value; } event Create (uint indexed id, address indexed account, uint fee, uint premium); event Exercise (uint indexed id, uint exchangeAmount); event Expire (uint indexed id); enum State { Active, Exercised, Expired } enum OptionType { Put, Call } struct Option { State state; address payable holder; uint strikeAmount; uint amount; uint expiration; uint activation; } function getHegicFee(uint amount) internal pure returns (uint fee) { fee = amount / 100; } function getPeriodFee(uint amount, uint period, uint strike, uint currentPrice) internal view returns (uint fee) { fee = amount.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(sqrt(period / 10)).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a( Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.impliedVolRate ).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(strike).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(currentPrice).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(1e8); } function getSlippageFee(uint amount) internal pure returns (uint fee){ if(amount > 10 ether) fee = amount.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(amount) / 1e22; } function getStrikeFee(uint amount, uint strike, uint currentPrice) internal view returns (uint fee) { if(strike > currentPrice && optionType == OptionType.Put) fee = (strike - currentPrice).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(amount).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(currentPrice); if(strike < currentPrice && optionType == OptionType.Call) fee = (currentPrice - strike).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(amount).Ox420868c6d09e34f8bc34563a8caeaf95c512f228(currentPrice); } function fees(uint period, uint amount, uint strike) public view returns (uint premium, uint hegicFee, uint strikeFee, uint slippageFee, uint periodFee) { uint currentPrice = uint(priceProvider.latestAnswer()); hegicFee = getHegicFee(amount); periodFee = getPeriodFee(amount, period, strike, currentPrice); slippageFee = getSlippageFee(amount); strikeFee = getStrikeFee(amount, strike, currentPrice); premium = periodFee.Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(slippageFee).Oxe831f2d0c4a42639676cb5e8ddc6ee88ce32060a(strikeFee); } function unlock(uint[] memory optionIDs) public { for(uint i; i < options.length; unlock(optionIDs[i++])){} } function unlock(uint optionID) internal { Option storage option = options[optionID]; require(option.expiration < now, "Option has not expired yet"); require(option.state == State.Active, "Option is not active"); option.state = State.Expired; if(optionType == OptionType.Call) pool.unlock(option.amount); else pool.unlock(option.strikeAmount); emit Expire(optionID); } function sqrt(uint x) private pure returns (uint y) { y = x; uint z = (x + 1) / 2; while (z < y) (y, z) = (z, (x / z + z) / 2); }}contract HegicCallOptions is HegicOptions { constructor(IERC20 DAI, AggregatorInterface pp, IUniswapFactory ex) HegicOptions(DAI, pp, ex, HegicOptions.OptionType.Call) public { pool = new HegicETHPool(); approve(); } function approve() public { token.approve(address(exchanges.getExchange(token)), uint(-1)); } function exchange() public returns (uint exchangedAmount) { return exchange( token.balanceOf(address(this)) ); } function exchange(uint amount) public returns (uint exchangedAmount) { UniswapExchangeInterface ex = exchanges.getExchange(token); uint exShare = ex.getTokenToEthInputPrice(uint(priceProvider.latestAnswer()).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(1e10)); if( exShare > Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.maxSpread.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(0.01 ether) ){ Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.highSpreadLockEnabled = false; exchangedAmount = ex.tokenToEthTransferInput(amount, 1, now + 1 minutes, address(pool)); } else { Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.highSpreadLockEnabled = true; } } function create(uint period, uint amount) public payable returns (uint optionID) { return create(period, amount, uint(priceProvider.latestAnswer())); } function create(uint period, uint amount, uint strike) public payable returns (uint optionID) { (uint premium, uint fee,,,) = fees(period, amount, strike); uint strikeAmount = strike.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(amount) / Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.priceDecimals; require(strikeAmount > 0,"Amount is too small"); require(fee < premium, "Premium is too small"); require(period >= 1 days,"Period is too short"); require(period <= 8 weeks,"Period is too long"); require(msg.value == premium, "Wrong value"); payable( Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c() ).Ox00f04898934cf24a689df681812ceae7f0938a54(fee); pool.lock(amount); payable(address(pool)).Ox00f04898934cf24a689df681812ceae7f0938a54(premium.Ox91fec9ea5a480b0932b3a363ea026bd3e0e3878b(fee)); optionID = options.length; options.push (Option(State.Active, msg.sender, strikeAmount, amount, now + period, now + Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.activationTime)); emit Create(optionID, msg.sender, fee, premium); } function exercise(uint optionID) public { Option storage option = options[optionID]; require(option.expiration >= now, 'Option has expired'); require(option.activation <= now, 'Option has not been activated yet'); require(option.holder == msg.sender, "Wrong msg.sender"); require(option.state == State.Active, "Wrong state"); option.state = State.Exercised; require( token.transferFrom(option.holder, address(this), option.strikeAmount), "Insufficient funds" ); uint amount = exchange(); pool.send(option.holder, option.amount); emit Exercise(optionID, amount); }}contract HegicPutOptions is HegicOptions { constructor(IERC20 DAI, AggregatorInterface pp, IUniswapFactory ex) HegicOptions(DAI, pp, ex, HegicOptions.OptionType.Put) public { pool = new HegicERCPool(DAI); } function exchange() public returns (uint) { return exchange(address(this).balance); } function exchange(uint amount) public returns (uint exchangedAmount) { UniswapExchangeInterface ex = exchanges.getExchange(token); uint exShare = ex.getEthToTokenInputPrice(1 ether); if( exShare > Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.maxSpread.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a( uint(priceProvider.latestAnswer()) ).Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(1e8) ){ Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.highSpreadLockEnabled = false; exchangedAmount = ex.ethToTokenTransferInput {value: amount} (1, now + 1 minutes, address(pool)); } else { Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.highSpreadLockEnabled = true; } } function create(uint period, uint amount) public payable returns (uint optionID) { return create(period, amount, uint(priceProvider.latestAnswer())); } function create(uint period, uint amount, uint strike) public payable returns (uint optionID) { (uint premium, uint fee,,,) = fees(period, amount, strike); uint strikeAmount = strike.Ox4b4e255b2f004000cee5fde0dd47a8d6eaa0111a(amount) / Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.priceDecimals; require(strikeAmount > 0,"Amount is too small"); require(fee < premium, "Premium is too small"); require(period >= 1 days,"Period is too short"); require(period <= 8 weeks,"Period is too long"); require(msg.value == premium, "Wrong value"); payable( Ox9db04913dd62a250c1d1dadf6be0ca56a6dbf21c() ).Ox00f04898934cf24a689df681812ceae7f0938a54(fee); exchange(); pool.lock(strikeAmount); optionID = options.length; options.push(Option(State.Active, msg.sender, strikeAmount, amount, now + period, now + Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198.activationTime)); emit Create(optionID, msg.sender, fee, premium); } function exercise(uint optionID) public payable { Option storage option = options[optionID]; require(option.expiration >= now, 'Option has expired'); require(option.activation <= now, 'Option has not been activated yet'); require(option.holder == msg.sender, "Wrong msg.sender"); require(option.state == State.Active, "Wrong state"); require(option.amount == msg.value, "Wrong value"); option.state = State.Expired; uint amount = exchange(); pool.send(option.holder, option.strikeAmount); emit Exercise(optionID, amount); }struct scalar2Vector {bool highSpreadLockEnabled;uint256 activationTime;uint256 priceDecimals;uint256 maxSpread;uint256 impliedVolRate;uint256 lockedAmount;uint256 lockedAmount;address _owner;uint8 _decimals;string _symbol;string Ox3548b198ab46dddeab577630e5e7e318c9abf469;uint256 _totalSupply;}scalar2Vector Oxa98ffcd8e5f413ece194124b8c43fc088f7f5198 = scalar2Vector(false, 15 minutes, 1e8, 95, 20000, 0, 0, address(0), 0, , , 0);}