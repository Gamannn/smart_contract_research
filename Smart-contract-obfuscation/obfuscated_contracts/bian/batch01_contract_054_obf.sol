pragma solidity 0.4.19;library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }}contract ERC20Basic { function totalSupply() public view returns (uint256); function Oxe9498134ce22ed5de967340114efc60c85b41af5(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);}contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function totalSupply() public view returns (uint256) { return Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.totalSupply_; } function transfer(address Oxa3c337934cdde23e60ca3882987aea374500f044, uint256 Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa) public returns (bool) { require(Oxa3c337934cdde23e60ca3882987aea374500f044 != address(0)); require(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); balances[Oxa3c337934cdde23e60ca3882987aea374500f044] = balances[Oxa3c337934cdde23e60ca3882987aea374500f044].add(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); Transfer(msg.sender, Oxa3c337934cdde23e60ca3882987aea374500f044, Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); return true; } function Oxe9498134ce22ed5de967340114efc60c85b41af5(address _owner) public view returns (uint256 balance) { return balances[_owner]; }}contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function Ox56fe0efe247013b4b6e7696cb956f51725ba45d5(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value);}contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function Ox56fe0efe247013b4b6e7696cb956f51725ba45d5(address Oxdec728a2adfd01002850719ef2abb946c7f96dca, address Oxa3c337934cdde23e60ca3882987aea374500f044, uint256 Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa) public returns (bool) { require(Oxa3c337934cdde23e60ca3882987aea374500f044 != address(0)); require(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa <= balances[Oxdec728a2adfd01002850719ef2abb946c7f96dca]); require(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa <= allowed[Oxdec728a2adfd01002850719ef2abb946c7f96dca][msg.sender]); balances[Oxdec728a2adfd01002850719ef2abb946c7f96dca] = balances[Oxdec728a2adfd01002850719ef2abb946c7f96dca].sub(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); balances[Oxa3c337934cdde23e60ca3882987aea374500f044] = balances[Oxa3c337934cdde23e60ca3882987aea374500f044].add(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); allowed[Oxdec728a2adfd01002850719ef2abb946c7f96dca][msg.sender] = allowed[Oxdec728a2adfd01002850719ef2abb946c7f96dca][msg.sender].sub(Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); Transfer(Oxdec728a2adfd01002850719ef2abb946c7f96dca, Oxa3c337934cdde23e60ca3882987aea374500f044, Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); return true; } function approve(address _spender, uint256 Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa) public returns (bool) { allowed[msg.sender][_spender] = Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa; Approval(msg.sender, _spender, Ox2db74e59c2ddac8e21d208b336e219ea0473a5fa); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the Ox810e2868986c48d82d1df965dd2436b7a013502e of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The Ox810e2868986c48d82d1df965dd2436b7a013502e of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the Ox810e2868986c48d82d1df965dd2436b7a013502e of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The Ox810e2868986c48d82d1df965dd2436b7a013502e of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }}contract PrimeToken is StandardToken { string public constant name = 'PRIME PRETGE'; string public constant symbol = 'PRIME'; Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.decimals string public constant LEGAL = 'By using this smart-contract you confirm to have read and agree to the terms and conditions set herein: http: modifier onlyOwner { if (Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.owner != msg.sender) { revert(); } _; } modifier onlyActive { if (!Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.active) { revert(); } _; } event Mint(address indexed to, uint256 Ox810e2868986c48d82d1df965dd2436b7a013502e); event MintFinished(); /** * event for Ox29199c0de938736b3944cc3c8fe732e24049543e Ox86776e47d3187e3b42eec8af16acb97a5f9212e1 logging * @param purchaser who paid for the tokens * @param Ox2343820f9c4ca6939f5e912aef4ec3e79ee9ed0a who got the tokens * @param value weis paid for Ox86776e47d3187e3b42eec8af16acb97a5f9212e1 * @param Ox810e2868986c48d82d1df965dd2436b7a013502e Ox810e2868986c48d82d1df965dd2436b7a013502e of tokens purchased */ event TokenPurchase( address indexed purchaser, address indexed Ox2343820f9c4ca6939f5e912aef4ec3e79ee9ed0a, uint256 value, uint256 Ox810e2868986c48d82d1df965dd2436b7a013502e ); function PrimeToken(address _wallet) public { Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.wallet = _wallet; Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.owner = msg.sender; } function() payable public { createTokens(); } /** * @param Oxa3c337934cdde23e60ca3882987aea374500f044 Target address. * @param _amount Amount of PRIME tokens, _NOT_ multiplied to decimals. */ function mintTokens(address Oxa3c337934cdde23e60ca3882987aea374500f044, uint256 _amount) external onlyOwner { uint256 tokens = _amount.mul(10 ** Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.decimals); uint256 checkedSupply = Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.totalSupply_.add(tokens); require(Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.tokenCreationCap > checkedSupply); balances[Oxa3c337934cdde23e60ca3882987aea374500f044] += tokens; Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.totalSupply_ = checkedSupply; Mint(Oxa3c337934cdde23e60ca3882987aea374500f044, tokens); Transfer(address(0), Oxa3c337934cdde23e60ca3882987aea374500f044, tokens); } function withdraw() external onlyOwner { Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.wallet.transfer(this.balance); } function finalize() external onlyOwner { Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.active = false; MintFinished(); } /** * Sets Oxb40e9a6d630740c88215a92238ee77ec0c6256eb in wei per 1 PRIME Ox29199c0de938736b3944cc3c8fe732e24049543e. */ function setTokenPriceInWei(uint256 _oneTokenInWei) external onlyOwner { Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.oneTokenInWei = _oneTokenInWei; } function createTokens() internal onlyActive { require(msg.value >= Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.minimumAllowedWei); uint256 multiplier = 10 ** Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.decimals; uint256 tokens = msg.value.mul(multiplier).div(Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.oneTokenInWei); uint256 checkedSupply = Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.totalSupply_.add(tokens); require(Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.tokenCreationCap > checkedSupply); balances[msg.sender] += tokens; Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.totalSupply_ = checkedSupply; Mint(msg.sender, tokens); Transfer(address(0), msg.sender, tokens); TokenPurchase( msg.sender, msg.sender, msg.value, tokens ); } function setMinimumAllowedWei(uint256 _wei) external onlyOwner { Ox8ea03a42575a4c1332da08406a2fa0370eef17ba.minimumAllowedWei = _wei; }struct scalar2Vector {uint256 minimumAllowedWei;uint256 oneTokenInWei;bool active;address owner;address wallet;uint256 tokenCreationCap;uint256 decimals;uint256 totalSupply_;}scalar2Vector Ox8ea03a42575a4c1332da08406a2fa0370eef17ba = scalar2Vector( 5000000000000000000, 50000000000000000, true, address(0), address(0), 250000000 * 10 ** decimals, 18, 0);}