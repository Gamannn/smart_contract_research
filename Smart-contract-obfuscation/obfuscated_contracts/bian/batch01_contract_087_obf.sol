pragma solidity ^0.4.24;contract ERC20 { event Approval(address indexed Oxe150cae77aa229e0e2625da026d404cbabfd0f60, address indexed _spender, uint256 _value); event Transfer(address indexed _from, address indexed _to, uint256 _value); function totalSupply() public view returns (uint256); function balanceOf(address Oxe150cae77aa229e0e2625da026d404cbabfd0f60) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function allowance(address Oxe150cae77aa229e0e2625da026d404cbabfd0f60, address _spender) public view returns (uint256); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool);}contract Owned { constructor() public { s2c.owner = msg.sender; } modifier onlyOwner { require(msg.sender == s2c.owner); _; } function transferOwnership(address Ox469684d655c655eed5cfcce148d1a33d7c076aa2) onlyOwner public { s2c.owner = Ox469684d655c655eed5cfcce148d1a33d7c076aa2; }}library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; } function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); uint256 c = a - b; return c; }}contract HashRush is ERC20, Owned { using SafeMath for uint256; mapping (address => uint256) balance; mapping (address => mapping (address => uint256)) allowed; modifier onlyPayloadSize(uint size) { if(msg.Ox5a590dfa74c9868c68713d63e2be1f34d96f111b.length < size.add(4)) revert(); _; } constructor(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 decimalMultiplier) public { s2c.name = tokenName; s2c.symbol = tokenSymbol; s2c.decimals = decimalUnits; s2c.multiplier = decimalMultiplier; } function totalSupply() public view returns (uint256) { return s2c.totalSupply_; } function allowance(address Oxe150cae77aa229e0e2625da026d404cbabfd0f60, address _spender) public view returns (uint256) { return allowed[Oxe150cae77aa229e0e2625da026d404cbabfd0f60][_spender]; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function balanceOf(address Oxe150cae77aa229e0e2625da026d404cbabfd0f60) public view returns (uint256) { return balance[Oxe150cae77aa229e0e2625da026d404cbabfd0f60]; } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) { require(_to != address(0)); require(_value <= balance[msg.sender]); if ((balance[msg.sender] >= _value) && (balance[_to].add(_value) > balance[_to]) ) { balance[msg.sender] = balance[msg.sender].sub(_value); balance[_to] = balance[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) { require(_to != address(0)); require(_value <= balance[_from]); require(_value <= allowed[_from][msg.sender]); if ((balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to].add(_value) > balance[_to])) { balance[_to] = balance[_to].add(_value); balance[_from] = balance[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } else { return false; } }}contract HashRushICO is Owned, HashRush { using SafeMath for uint256; constructor() HashRush(s2c.tokenName, s2c.tokenSymbol, s2c.decimalUnits, multiplier) public { s2c.multiSigWallet = msg.sender; s2c.fixedTotalSupply = 70000000; s2c.fixedTotalSupply = s2c.fixedTotalSupply.mul(multiplier); } function () public payable { require(!s2c.crowdsaleClosed && (now < s2c.stopTime) && (msg.value >= s2c.minimumInvestment) && (s2c.totalSupply_.add(msg.value.mul(s2c.price).mul(multiplier).div(1 ether)) <= s2c.fixedTotalSupply) && (s2c.amountRaised.add(msg.value.div(1 ether)) <= s2c.crowdsaleTarget) ); address recipient = msg.sender; s2c.amountRaised = s2c.amountRaised.add(msg.value.div(1 ether)); uint256 tokens = msg.value.mul(s2c.price).mul(multiplier).div(1 ether); s2c.totalSupply_ = s2c.totalSupply_.add(tokens); } function mintToken(address target, uint256 amount) onlyOwner public returns (bool) { require(amount > 0); require(s2c.totalSupply_.add(amount) <= s2c.fixedTotalSupply); uint256 addTokens = amount; balance[target] = balance[target].add(addTokens); s2c.totalSupply_ = s2c.totalSupply_.add(addTokens); emit Transfer(0, target, addTokens); return true; } function setPrice(uint256 newPriceperEther) onlyOwner public returns (uint256) { require(newPriceperEther > 0); s2c.price = newPriceperEther; return s2c.price; } /** * @dev Function to set the multisig wallet for a crowdsale * @param wallet Wallet address. * @return A boolean that indicates if the operation was successful. */ function setMultiSigWallet(address wallet) onlyOwner public returns (bool) { s2c.multiSigWallet = wallet; return true; } /** * @dev Function to set the minimum investment to participate in crowdsale * @param minimum minimum amount in wei. * @return A boolean that indicates if the operation was successful. */ function setMinimumInvestment(uint256 minimum) onlyOwner public returns (bool) { s2c.minimumInvestment = minimum; return true; } /** * @dev Function to set the crowdsale target * @param target Target amount in ETH. * @return A boolean that indicates if the operation was successful. */ function setCrowdsaleTarget(uint256 target) onlyOwner public returns (bool) { s2c.crowdsaleTarget = target; return true; } /** * @dev Function to start the crowdsale specifying startTime and stopTime * @param saleStart Sale start timestamp. * @param saleStop Sale stop timestamo. * @param salePrice Token price per ether. * @param setBeneficiary Beneficiary address. * @param minInvestment Minimum investment to participate in crowdsale (wei). * @param saleTarget Crowdsale target in ETH * @return A boolean that indicates if the operation was successful. */ function startSale(uint256 saleStart, uint256 saleStop, uint256 salePrice, address setBeneficiary, uint256 minInvestment, uint256 saleTarget) onlyOwner public returns (bool) { require(saleStop > now); s2c.startTime = saleStart; s2c.stopTime = saleStop; s2c.amountRaised = 0; s2c.crowdsaleClosed = false; setPrice(salePrice); setMultiSigWallet(setBeneficiary); setMinimumInvestment(minInvestment); setCrowdsaleTarget(saleTarget); return true; } /** * @dev Function that allows owner to stop the crowdsale immediately * @return A boolean that indicates if the operation was successful. */ function stopSale() onlyOwner public returns (bool) { s2c.stopTime = now; s2c.crowdsaleClosed = true; return true; }struct scalar2Vector {uint8 decimalUnits;uint256 multiplier;string tokenSymbol;string tokenName;bool crowdsaleClosed;uint256 crowdsaleTarget;uint256 minimumInvestment;uint256 price;uint256 fixedTotalSupply;uint256 stopTime;uint256 startTime;uint256 amountRaised;address multiSigWallet;uint256 multiplier;uint256 totalSupply_;uint256 decimals;string symbol;string name;address owner;}scalar2Vector s2c = scalar2Vector( 8, 100000000, "RUSH", "HashRush", true, 0, 0, 0, 0, 0, 0, 0, address(0), 0, 0, 0, , , address(0));}