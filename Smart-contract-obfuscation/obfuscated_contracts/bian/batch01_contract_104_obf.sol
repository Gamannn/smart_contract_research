pragma solidity 0.4.24;contract ERC20Basic { function Ox7ac56db59149c295858d2cbddb2db0cacef3d2d4() public view returns (uint256); function Ox981c3635c7bf8e19934a068b4d2e04d0e20217d9(address who) public view returns (uint256); function Ox9e77ca043e23d4424170be471b4632d20f2d94d8(address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577) public returns (bool); event Transfer(address indexed Oxe28ad47fd58d856c08155914fa0e9ba758066f85, address indexed Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577);}contract ERC20 is ERC20Basic { function Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95(address Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, address Oxece009e1b0e715e437b13b1aeb298afdc6b53902) public view returns (uint256); function Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921(address Oxe28ad47fd58d856c08155914fa0e9ba758066f85, address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577) public returns (bool); function Oxf13798447bf00e84147a365173f975f3f4bf6ff7(address Oxece009e1b0e715e437b13b1aeb298afdc6b53902, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577) public returns (bool); event Approval( address indexed Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, address indexed Oxece009e1b0e715e437b13b1aeb298afdc6b53902, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577 );}library Ox5cda3019fa30e31c07a3b7e5da4f3722f0d46526 { function Oxa1df55cf732334edf7ee1c6f99208cbba72f31c4(uint256 Oxd56f0da56258478530c68b005f8751eef529708f, uint256 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint256 Ox83147bfd5148545b99b9a3db983bd80860a81331) { if (Oxd56f0da56258478530c68b005f8751eef529708f == 0) { return 0; } Ox83147bfd5148545b99b9a3db983bd80860a81331 = Oxd56f0da56258478530c68b005f8751eef529708f * Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; assert(Ox83147bfd5148545b99b9a3db983bd80860a81331 / Oxd56f0da56258478530c68b005f8751eef529708f == Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6); return Ox83147bfd5148545b99b9a3db983bd80860a81331; } function Ox2e75a7159828e1253be4da33349dddaed1ceddb1(uint256 Oxd56f0da56258478530c68b005f8751eef529708f, uint256 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint256) { return Oxd56f0da56258478530c68b005f8751eef529708f / Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; } function Ox456a1e013a614f20a09c7da191fd08bf32fad494(uint256 Oxd56f0da56258478530c68b005f8751eef529708f, uint256 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint256) { assert(Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6 <= Oxd56f0da56258478530c68b005f8751eef529708f); return Oxd56f0da56258478530c68b005f8751eef529708f - Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; } function Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(uint256 Oxd56f0da56258478530c68b005f8751eef529708f, uint256 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint256 Ox83147bfd5148545b99b9a3db983bd80860a81331) { Ox83147bfd5148545b99b9a3db983bd80860a81331 = Oxd56f0da56258478530c68b005f8751eef529708f + Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; assert(Ox83147bfd5148545b99b9a3db983bd80860a81331 >= Oxd56f0da56258478530c68b005f8751eef529708f); return Ox83147bfd5148545b99b9a3db983bd80860a81331; }}contract Ownable { event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed Oxaa60403e71772fe5ff3f5def2f236cc121a06e8e ); constructor() public { s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 = msg.sender; } modifier Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806() { require(msg.sender == s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704); _; } function renounceOwnership() public Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit OwnershipRenounced(s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704); s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 = address(0); } function Oxa796d3c9a9a923930671c032eb5825d9f949e500(address _newOwner) public Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, _newOwner); s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 = _newOwner; }}contract BasicToken is ERC20Basic { using Ox5cda3019fa30e31c07a3b7e5da4f3722f0d46526 for uint256; mapping(address => uint256) balances; function Ox7ac56db59149c295858d2cbddb2db0cacef3d2d4() public view returns (uint256) { return s2c.totalSupply_; } /** * @dev Transfer token for Oxd56f0da56258478530c68b005f8751eef529708f specified address * @param Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30 The address Oxdae921211bf3abdb04d206b007b12bc509c30330 Ox9e77ca043e23d4424170be471b4632d20f2d94d8 Oxdae921211bf3abdb04d206b007b12bc509c30330. * @param Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 The Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b Oxdae921211bf3abdb04d206b007b12bc509c30330 be transferred. */ function Ox9e77ca043e23d4424170be471b4632d20f2d94d8(address Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) public returns (bool) { require(Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30 != address(0)); require(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); balances[Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30] = balances[Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30].Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); emit Transfer(msg.sender, Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address Oxdae921211bf3abdb04d206b007b12bc509c30330 query the the balance of. * @return An uint256 representing the Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b Oxc7a71bc0f1b409c24e889c2d21df52467078b5e5 by the passed address. */ function Ox981c3635c7bf8e19934a068b4d2e04d0e20217d9(address _owner) public view returns (uint256) { return balances[_owner]; }}/** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https: * Based on code by FirstBlood: https: */contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens Oxe28ad47fd58d856c08155914fa0e9ba758066f85 one address Oxdae921211bf3abdb04d206b007b12bc509c30330 another * @param Ox5735475372f1a0650f931f3b7eb7804d60574db6 address The address which you want Oxdae921211bf3abdb04d206b007b12bc509c30330 send tokens Oxe28ad47fd58d856c08155914fa0e9ba758066f85 * @param Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30 address The address which you want Oxdae921211bf3abdb04d206b007b12bc509c30330 Ox9e77ca043e23d4424170be471b4632d20f2d94d8 Oxdae921211bf3abdb04d206b007b12bc509c30330 * @param Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 uint256 the Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens Oxdae921211bf3abdb04d206b007b12bc509c30330 be transferred */ function Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921( address Ox5735475372f1a0650f931f3b7eb7804d60574db6, address Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 ) public returns (bool) { require(Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30 != address(0)); require(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 <= balances[Ox5735475372f1a0650f931f3b7eb7804d60574db6]); require(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 <= allowed[Ox5735475372f1a0650f931f3b7eb7804d60574db6][msg.sender]); balances[Ox5735475372f1a0650f931f3b7eb7804d60574db6] = balances[Ox5735475372f1a0650f931f3b7eb7804d60574db6].Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); balances[Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30] = balances[Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30].Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); allowed[Ox5735475372f1a0650f931f3b7eb7804d60574db6][msg.sender] = allowed[Ox5735475372f1a0650f931f3b7eb7804d60574db6][msg.sender].Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); emit Transfer(Ox5735475372f1a0650f931f3b7eb7804d60574db6, Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); return true; } /** * @dev Approve the passed address Oxdae921211bf3abdb04d206b007b12bc509c30330 spend the specified Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens on behalf of msg.sender. * Beware that changing an Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95 with this method brings the risk that someone may use both the old * and the new Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95 by unfortunate transaction ordering. One possible solution Oxdae921211bf3abdb04d206b007b12bc509c30330 mitigate this * race condition is Oxdae921211bf3abdb04d206b007b12bc509c30330 first reduce the Oxece009e1b0e715e437b13b1aeb298afdc6b53902's Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95 Oxdae921211bf3abdb04d206b007b12bc509c30330 0 and set the desired Ox8c41d7c2a90735aca36d993c6db992ee1b858577 afterwards: * https: * @param Ox85d1cb6a882d25a34e50474d0c45795600ce664e The address which will spend the funds. * @param Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 The Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens Oxdae921211bf3abdb04d206b007b12bc509c30330 be spent. */ function Oxf13798447bf00e84147a365173f975f3f4bf6ff7(address Ox85d1cb6a882d25a34e50474d0c45795600ce664e, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) public returns (bool) { allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e] = Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6; emit Approval(msg.sender, Ox85d1cb6a882d25a34e50474d0c45795600ce664e, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); return true; } /** * @dev Function Oxdae921211bf3abdb04d206b007b12bc509c30330 check the Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens that an Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 allowed Oxdae921211bf3abdb04d206b007b12bc509c30330 Oxd56f0da56258478530c68b005f8751eef529708f Oxece009e1b0e715e437b13b1aeb298afdc6b53902. * @param _owner address The address which owns the funds. * @param Ox85d1cb6a882d25a34e50474d0c45795600ce664e address The address which will spend the funds. * @return A uint256 specifying the Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens still available for the Oxece009e1b0e715e437b13b1aeb298afdc6b53902. */ function Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95( address _owner, address Ox85d1cb6a882d25a34e50474d0c45795600ce664e ) public view returns (uint256) { return allowed[_owner][Ox85d1cb6a882d25a34e50474d0c45795600ce664e]; } /** * @dev Increase the Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens that an Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 allowed Oxdae921211bf3abdb04d206b007b12bc509c30330 Oxd56f0da56258478530c68b005f8751eef529708f Oxece009e1b0e715e437b13b1aeb298afdc6b53902. * Oxf13798447bf00e84147a365173f975f3f4bf6ff7 should be called when allowed[Ox85d1cb6a882d25a34e50474d0c45795600ce664e] == 0. To increment * allowed Ox8c41d7c2a90735aca36d993c6db992ee1b858577 is better Oxdae921211bf3abdb04d206b007b12bc509c30330 use this function Oxdae921211bf3abdb04d206b007b12bc509c30330 avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param Ox85d1cb6a882d25a34e50474d0c45795600ce664e The address which will spend the funds. * @param _addedValue The Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens Oxdae921211bf3abdb04d206b007b12bc509c30330 increase the Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95 by. */ function increaseApproval( address Ox85d1cb6a882d25a34e50474d0c45795600ce664e, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e] = ( allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e].Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(_addedValue)); emit Approval(msg.sender, Ox85d1cb6a882d25a34e50474d0c45795600ce664e, allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e]); return true; } /** * @dev Decrease the Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens that an Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 allowed Oxdae921211bf3abdb04d206b007b12bc509c30330 Oxd56f0da56258478530c68b005f8751eef529708f Oxece009e1b0e715e437b13b1aeb298afdc6b53902. * Oxf13798447bf00e84147a365173f975f3f4bf6ff7 should be called when allowed[Ox85d1cb6a882d25a34e50474d0c45795600ce664e] == 0. To decrement * allowed Ox8c41d7c2a90735aca36d993c6db992ee1b858577 is better Oxdae921211bf3abdb04d206b007b12bc509c30330 use this function Oxdae921211bf3abdb04d206b007b12bc509c30330 avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param Ox85d1cb6a882d25a34e50474d0c45795600ce664e The address which will spend the funds. * @param _subtractedValue The Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens Oxdae921211bf3abdb04d206b007b12bc509c30330 decrease the Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95 by. */ function decreaseApproval( address Ox85d1cb6a882d25a34e50474d0c45795600ce664e, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e]; if (_subtractedValue > oldValue) { allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e] = 0; } else { allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e] = oldValue.Ox456a1e013a614f20a09c7da191fd08bf32fad494(_subtractedValue); } emit Approval(msg.sender, Ox85d1cb6a882d25a34e50474d0c45795600ce664e, allowed[msg.sender][Ox85d1cb6a882d25a34e50474d0c45795600ce664e]); return true; }}/** * @title Pausable * @dev Base contract which allows children Oxdae921211bf3abdb04d206b007b12bc509c30330 implement an emergency stop mechanism. */contract Pausable is Ownable { event Pause(); event Unpause(); /** * @dev Modifier Oxdae921211bf3abdb04d206b007b12bc509c30330 make Oxd56f0da56258478530c68b005f8751eef529708f function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!s2c.paused); _; } /** * @dev Modifier Oxdae921211bf3abdb04d206b007b12bc509c30330 make Oxd56f0da56258478530c68b005f8751eef529708f function callable only when the contract is paused. */ modifier whenPaused() { require(s2c.paused); _; } /** * @dev called by the Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 Oxdae921211bf3abdb04d206b007b12bc509c30330 pause, triggers stopped state */ function pause() Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 whenNotPaused public { s2c.paused = true; emit Pause(); } /** * @dev called by the Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704 Oxdae921211bf3abdb04d206b007b12bc509c30330 unpause, returns Oxdae921211bf3abdb04d206b007b12bc509c30330 normal state */ function unpause() Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 whenPaused public { s2c.paused = false; emit Unpause(); }}/** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/contract PausableToken is StandardToken, Pausable { function Ox9e77ca043e23d4424170be471b4632d20f2d94d8( address Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 ) public whenNotPaused returns (bool) { return super.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } function Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921( address Ox5735475372f1a0650f931f3b7eb7804d60574db6, address Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 ) public whenNotPaused returns (bool) { return super.Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921(Ox5735475372f1a0650f931f3b7eb7804d60574db6, Ox4dda96d03e2fa5bdcb72fa84b63ecabc303b0c30, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } function Oxf13798447bf00e84147a365173f975f3f4bf6ff7( address Ox85d1cb6a882d25a34e50474d0c45795600ce664e, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 ) public whenNotPaused returns (bool) { return super.Oxf13798447bf00e84147a365173f975f3f4bf6ff7(Ox85d1cb6a882d25a34e50474d0c45795600ce664e, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } function increaseApproval( address Ox85d1cb6a882d25a34e50474d0c45795600ce664e, uint _addedValue ) public whenNotPaused returns (bool Oxf8b2c5504b89f9084f99f0506d630f86a8558a0f) { return super.increaseApproval(Ox85d1cb6a882d25a34e50474d0c45795600ce664e, _addedValue); } function decreaseApproval( address Ox85d1cb6a882d25a34e50474d0c45795600ce664e, uint _subtractedValue ) public whenNotPaused returns (bool Oxf8b2c5504b89f9084f99f0506d630f86a8558a0f) { return super.decreaseApproval(Ox85d1cb6a882d25a34e50474d0c45795600ce664e, _subtractedValue); }}/** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577); /** * @dev Burns Oxd56f0da56258478530c68b005f8751eef529708f specific Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of tokens. * @param Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 The Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b of token Oxdae921211bf3abdb04d206b007b12bc509c30330 be burned. */ function Oxe5bb052c912e1c257d552be2b0e7f2d564bc4d09(uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) public { _burn(msg.sender, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } function _burn(address _who, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) internal { require(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 <= balances[_who]); balances[_who] = balances[_who].Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); s2c.totalSupply_ = s2c.totalSupply_.Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); emit Burn(_who, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); emit Transfer(_who, address(0), Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); }}contract RepublicToken is PausableToken, BurnableToken { s2c.Ox97403ffef8701ac621cbb41be529b4451f71ee94 constructor() public { s2c.totalSupply_ = s2c.INITIAL_SUPPLY; balances[msg.sender] = s2c.INITIAL_SUPPLY; } function transferTokens(address beneficiary, uint256 Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b) public Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns (bool) { /* solium-disable error-reason */ require(Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b > 0); balances[s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704] = balances[s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704].Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); balances[beneficiary] = balances[beneficiary].Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); emit Transfer(s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, beneficiary, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); return true; }}/** * @notice LinkedList is Oxd56f0da56258478530c68b005f8751eef529708f library for Oxd56f0da56258478530c68b005f8751eef529708f circular double linked list. */library LinkedList { /* * @notice A permanent NULL node (0x0) in the circular double linked list. * NULL.next is the head, and NULL.previous is the tail. */ /** * @notice A node points Oxdae921211bf3abdb04d206b007b12bc509c30330 the node before it, and the node after it. If * node.previous = NULL, then the node is the head of the list. If * node.next = NULL, then the node is the tail of the list. */ struct Node { bool inList; address previous; address next; } /** * @notice LinkedList uses Oxd56f0da56258478530c68b005f8751eef529708f mapping Oxe28ad47fd58d856c08155914fa0e9ba758066f85 address Oxdae921211bf3abdb04d206b007b12bc509c30330 nodes. Each address * uniquely identifies Oxd56f0da56258478530c68b005f8751eef529708f node, and in this way they are used like pointers. */ struct List { mapping (address => Node) list; } /** * @notice Insert Oxd56f0da56258478530c68b005f8751eef529708f new node before an existing node. * * @param self The list being used. * @param Ox15fd1f3a6dec96064ea877340956efac6284fd22 The existing node in the list. * @param newNode The next node Oxdae921211bf3abdb04d206b007b12bc509c30330 insert before the Ox15fd1f3a6dec96064ea877340956efac6284fd22. */ function insertBefore(List storage self, address Ox15fd1f3a6dec96064ea877340956efac6284fd22, address newNode) internal { require(!isInList(self, newNode), "already in list"); require(isInList(self, Ox15fd1f3a6dec96064ea877340956efac6284fd22) || Ox15fd1f3a6dec96064ea877340956efac6284fd22 == s2c.NULL, "not in list"); address prev = self.list[Ox15fd1f3a6dec96064ea877340956efac6284fd22].previous; self.list[newNode].next = Ox15fd1f3a6dec96064ea877340956efac6284fd22; self.list[newNode].previous = prev; self.list[Ox15fd1f3a6dec96064ea877340956efac6284fd22].previous = newNode; self.list[prev].next = newNode; self.list[newNode].inList = true; } /** * @notice Insert Oxd56f0da56258478530c68b005f8751eef529708f new node after an existing node. * * @param self The list being used. * @param Ox15fd1f3a6dec96064ea877340956efac6284fd22 The existing node in the list. * @param newNode The next node Oxdae921211bf3abdb04d206b007b12bc509c30330 insert after the Ox15fd1f3a6dec96064ea877340956efac6284fd22. */ function insertAfter(List storage self, address Ox15fd1f3a6dec96064ea877340956efac6284fd22, address newNode) internal { require(!isInList(self, newNode), "already in list"); require(isInList(self, Ox15fd1f3a6dec96064ea877340956efac6284fd22) || Ox15fd1f3a6dec96064ea877340956efac6284fd22 == s2c.NULL, "not in list"); address n = self.list[Ox15fd1f3a6dec96064ea877340956efac6284fd22].next; self.list[newNode].previous = Ox15fd1f3a6dec96064ea877340956efac6284fd22; self.list[newNode].next = n; self.list[Ox15fd1f3a6dec96064ea877340956efac6284fd22].next = newNode; self.list[n].previous = newNode; self.list[newNode].inList = true; } /** * @notice Remove Oxd56f0da56258478530c68b005f8751eef529708f node Oxe28ad47fd58d856c08155914fa0e9ba758066f85 the list, and fix the previous and next * pointers that are pointing Oxdae921211bf3abdb04d206b007b12bc509c30330 the removed node. Removing anode that is not * in the list will do nothing. * * @param self The list being using. * @param node The node in the list Oxdae921211bf3abdb04d206b007b12bc509c30330 be removed. */ function remove(List storage self, address node) internal { require(isInList(self, node), "not in list"); if (node == s2c.NULL) { return; } address p = self.list[node].previous; address n = self.list[node].next; self.list[p].next = n; self.list[n].previous = p; self.list[node].inList = false; delete self.list[node]; } /** * @notice Insert Oxd56f0da56258478530c68b005f8751eef529708f node at the beginning of the list. * * @param self The list being used. * @param node The node Oxdae921211bf3abdb04d206b007b12bc509c30330 insert at the beginning of the list. */ function prepend(List storage self, address node) internal { insertBefore(self, begin(self), node); } /** * @notice Insert Oxd56f0da56258478530c68b005f8751eef529708f node at the end of the list. * * @param self The list being used. * @param node The node Oxdae921211bf3abdb04d206b007b12bc509c30330 insert at the end of the list. */ function append(List storage self, address node) internal { insertAfter(self, end(self), node); } function swap(List storage self, address left, address right) internal { address previousRight = self.list[right].previous; remove(self, right); insertAfter(self, left, right); remove(self, left); insertAfter(self, previousRight, left); } function isInList(List storage self, address node) internal view returns (bool) { return self.list[node].inList; } /** * @notice Get the node at the beginning of Oxd56f0da56258478530c68b005f8751eef529708f double linked list. * * @param self The list being used. * * @return A address identifying the node at the beginning of the double * linked list. */ function begin(List storage self) internal view returns (address) { return self.list[s2c.NULL].next; } /** * @notice Get the node at the end of Oxd56f0da56258478530c68b005f8751eef529708f double linked list. * * @param self The list being used. * * @return A address identifying the node at the end of the double linked * list. */ function end(List storage self) internal view returns (address) { return self.list[s2c.NULL].previous; } function next(List storage self, address node) internal view returns (address) { require(isInList(self, node), "not in list"); return self.list[node].next; } function previous(List storage self, address node) internal view returns (address) { require(isInList(self, node), "not in list"); return self.list[node].previous; }}contract DarknodeRegistryStore is Ownable { struct Darknode { address Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704; uint256 bond; uint256 registeredAt; uint256 deregisteredAt; bytes publicKey; } mapping(address => Darknode) private darknodeRegistry; LinkedList.List private darknodes; RepublicToken public ren; constructor( string _VERSION, RepublicToken _ren ) public { s2c.VERSION = _VERSION; ren = _ren; } function appendDarknode( address _darknodeID, address _darknodeOwner, uint256 _bond, bytes _publicKey, uint256 _registeredAt, uint256 _deregisteredAt ) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { Darknode memory darknode = Darknode({ Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704: _darknodeOwner, bond: _bond, publicKey: _publicKey, registeredAt: _registeredAt, deregisteredAt: _deregisteredAt }); darknodeRegistry[_darknodeID] = darknode; LinkedList.append(darknodes, _darknodeID); } function begin() external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns(address) { return LinkedList.begin(darknodes); } function next(address darknodeID) external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns(address) { return LinkedList.next(darknodes, darknodeID); } function removeDarknode(address darknodeID) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { uint256 bond = darknodeRegistry[darknodeID].bond; delete darknodeRegistry[darknodeID]; LinkedList.remove(darknodes, darknodeID); require(ren.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, bond), "bond Ox9e77ca043e23d4424170be471b4632d20f2d94d8 failed"); } function updateDarknodeBond(address darknodeID, uint256 bond) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { uint256 previousBond = darknodeRegistry[darknodeID].bond; darknodeRegistry[darknodeID].bond = bond; if (previousBond > bond) { require(ren.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, previousBond - bond), "cannot Ox9e77ca043e23d4424170be471b4632d20f2d94d8 bond"); } } function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt; } function darknodeOwner(address darknodeID) external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns (address) { return darknodeRegistry[darknodeID].Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704; } function darknodeBond(address darknodeID) external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns (uint256) { return darknodeRegistry[darknodeID].bond; } function darknodeRegisteredAt(address darknodeID) external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns (uint256) { return darknodeRegistry[darknodeID].registeredAt; } function darknodeDeregisteredAt(address darknodeID) external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns (uint256) { return darknodeRegistry[darknodeID].deregisteredAt; } function darknodePublicKey(address darknodeID) external view Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 returns (bytes) { return darknodeRegistry[darknodeID].publicKey; }}contract DarknodeRegistry is Ownable { struct Epoch { uint256 epochhash; uint256 blocknumber; } Epoch public currentEpoch; Epoch public previousEpoch; RepublicToken public ren; DarknodeRegistryStore public store; event LogDarknodeRegistered(address _darknodeID, uint256 _bond); event LogDarknodeDeregistered(address _darknodeID); event LogDarknodeOwnerRefunded(address _owner, uint256 _amount); event LogNewEpoch(); event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond); event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize); event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval); event LogSlasherUpdated(address previousSlasher, address nextSlasher); modifier onlyDarknodeOwner(address _darknodeID) { require(store.darknodeOwner(_darknodeID) == msg.sender, "must be darknode Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704"); _; } modifier onlyRefunded(address _darknodeID) { require(isRefunded(_darknodeID), "must be refunded or never registered"); _; } modifier onlyRefundable(address _darknodeID) { require(isRefundable(_darknodeID), "must be deregistered for at least one epoch"); _; } modifier onlyDeregisterable(address _darknodeID) { require(isDeregisterable(_darknodeID), "must be deregisterable"); _; } modifier onlySlasher() { require(s2c.slasher == msg.sender, "must be slasher"); _; } constructor( string _VERSION, RepublicToken _renAddress, DarknodeRegistryStore _storeAddress, uint256 _minimumBond, uint256 _minimumPodSize, uint256 _minimumEpochInterval ) public { VERSION = _VERSION; store = _storeAddress; ren = _renAddress; s2c.minimumBond = _minimumBond; s2c.nextMinimumBond = s2c.minimumBond; s2c.minimumPodSize = _minimumPodSize; s2c.nextMinimumPodSize = s2c.minimumPodSize; s2c.minimumEpochInterval = _minimumEpochInterval; s2c.nextMinimumEpochInterval = s2c.minimumEpochInterval; currentEpoch = Epoch({ epochhash: uint256(blockhash(block.number - 1)), blocknumber: block.number }); s2c.numDarknodes = 0; s2c.numDarknodesNextEpoch = 0; s2c.numDarknodesPreviousEpoch = 0; } function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) { require(_bond >= s2c.minimumBond, "insufficient bond"); require(ren.Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921(msg.sender, address(this), _bond), "bond Ox9e77ca043e23d4424170be471b4632d20f2d94d8 failed"); ren.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(address(store), _bond); store.appendDarknode( _darknodeID, msg.sender, _bond, _publicKey, currentEpoch.blocknumber + s2c.minimumEpochInterval, 0 ); s2c.numDarknodesNextEpoch += 1; emit LogDarknodeRegistered(_darknodeID, _bond); } function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) { store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + s2c.minimumEpochInterval); s2c.numDarknodesNextEpoch -= 1; emit LogDarknodeDeregistered(_darknodeID); } function epoch() external { if (previousEpoch.blocknumber == 0) { require(msg.sender == s2c.Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, "not authorized (first epochs)"); } require(block.number >= currentEpoch.blocknumber + s2c.minimumEpochInterval, "epoch interval has not passed"); uint256 epochhash = uint256(blockhash(block.number - 1)); previousEpoch = currentEpoch; currentEpoch = Epoch({ epochhash: epochhash, blocknumber: block.number }); s2c.numDarknodesPreviousEpoch = s2c.numDarknodes; s2c.numDarknodes = s2c.numDarknodesNextEpoch; if (s2c.nextMinimumBond != s2c.minimumBond) { s2c.minimumBond = s2c.nextMinimumBond; emit LogMinimumBondUpdated(s2c.minimumBond, s2c.nextMinimumBond); } if (s2c.nextMinimumPodSize != s2c.minimumPodSize) { s2c.minimumPodSize = s2c.nextMinimumPodSize; emit LogMinimumPodSizeUpdated(s2c.minimumPodSize, s2c.nextMinimumPodSize); } if (s2c.nextMinimumEpochInterval != s2c.minimumEpochInterval) { s2c.minimumEpochInterval = s2c.nextMinimumEpochInterval; emit LogMinimumEpochIntervalUpdated(s2c.minimumEpochInterval, s2c.nextMinimumEpochInterval); } if (s2c.nextSlasher != s2c.slasher) { s2c.slasher = s2c.nextSlasher; emit LogSlasherUpdated(s2c.slasher, s2c.nextSlasher); } emit LogNewEpoch(); } function transferStoreOwnership(address _newOwner) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { store.Oxa796d3c9a9a923930671c032eb5825d9f949e500(_newOwner); } function updateMinimumBond(uint256 _nextMinimumBond) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { s2c.nextMinimumBond = _nextMinimumBond; } function updateMinimumPodSize(uint256 _nextMinimumPodSize) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { s2c.nextMinimumPodSize = _nextMinimumPodSize; } function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { s2c.nextMinimumEpochInterval = _nextMinimumEpochInterval; } function updateSlasher(address _slasher) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { s2c.nextSlasher = _slasher; } function slash(address _prover, address _challenger1, address _challenger2) external onlySlasher { uint256 penalty = store.darknodeBond(_prover) / 2; uint256 reward = penalty / 4; store.updateDarknodeBond(_prover, penalty); if (isDeregisterable(_prover)) { store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + s2c.minimumEpochInterval); s2c.numDarknodesNextEpoch -= 1; emit LogDarknodeDeregistered(_prover); } ren.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(store.darknodeOwner(_challenger1), reward); ren.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(store.darknodeOwner(_challenger2), reward); } function refund(address _darknodeID) external onlyRefundable(_darknodeID) { address darknodeOwner = store.darknodeOwner(_darknodeID); uint256 Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b = store.darknodeBond(_darknodeID); store.removeDarknode(_darknodeID); ren.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(darknodeOwner, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); emit LogDarknodeOwnerRefunded(darknodeOwner, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); } function getDarknodeOwner(address _darknodeID) external view returns (address) { return store.darknodeOwner(_darknodeID); } function getDarknodeBond(address _darknodeID) external view returns (uint256) { return store.darknodeBond(_darknodeID); } function getDarknodePublicKey(address _darknodeID) external view returns (bytes) { return store.darknodePublicKey(_darknodeID); } function getDarknodes(address _start, uint256 _count) external view returns (address[]) { uint256 count = _count; if (count == 0) { count = s2c.numDarknodes; } return getDarknodesFromEpochs(_start, count, false); } function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) { uint256 count = _count; if (count == 0) { count = s2c.numDarknodesPreviousEpoch; } return getDarknodesFromEpochs(_start, count, true); } function isPendingRegistration(address _darknodeID) external view returns (bool) { uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID); return registeredAt != 0 && registeredAt > currentEpoch.blocknumber; } function isPendingDeregistration(address _darknodeID) external view returns (bool) { uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber; } function isDeregistered(address _darknodeID) public view returns (bool) { uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber; } function isDeregisterable(address _darknodeID) public view returns (bool) { uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return isRegistered(_darknodeID) && deregisteredAt == 0; } function isRefunded(address _darknodeID) public view returns (bool) { uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID); uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return registeredAt == 0 && deregisteredAt == 0; } function isRefundable(address _darknodeID) public view returns (bool) { return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber; } function isRegistered(address _darknodeID) public view returns (bool) { return isRegisteredInEpoch(_darknodeID, currentEpoch); } function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) { return isRegisteredInEpoch(_darknodeID, previousEpoch); } function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) { uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID); uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber; bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber; return registered && notDeregistered; } function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) { uint256 count = _count; if (count == 0) { count = s2c.numDarknodes; } address[] memory nodes = new address[](count); uint256 n = 0; address next = _start; if (next == 0x0) { next = store.begin(); } while (n < count) { if (next == 0x0) { break; } bool includeNext; if (_usePreviousEpoch) { includeNext = isRegisteredInPreviousEpoch(next); } else { includeNext = isRegistered(next); } if (!includeNext) { next = store.next(next); continue; } nodes[n] = next; next = store.next(next); n += 1; } return nodes; }}/** * @title Math * @dev Assorted math operations */library Math { function max64(uint64 Oxd56f0da56258478530c68b005f8751eef529708f, uint64 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint64) { return Oxd56f0da56258478530c68b005f8751eef529708f >= Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6 ? Oxd56f0da56258478530c68b005f8751eef529708f : Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; } function min64(uint64 Oxd56f0da56258478530c68b005f8751eef529708f, uint64 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint64) { return Oxd56f0da56258478530c68b005f8751eef529708f < Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6 ? Oxd56f0da56258478530c68b005f8751eef529708f : Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; } function max256(uint256 Oxd56f0da56258478530c68b005f8751eef529708f, uint256 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint256) { return Oxd56f0da56258478530c68b005f8751eef529708f >= Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6 ? Oxd56f0da56258478530c68b005f8751eef529708f : Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; } function min256(uint256 Oxd56f0da56258478530c68b005f8751eef529708f, uint256 Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6) internal pure returns (uint256) { return Oxd56f0da56258478530c68b005f8751eef529708f < Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6 ? Oxd56f0da56258478530c68b005f8751eef529708f : Oxe84ffb5232a7409ab86510726a91fd6b2a7c36d6; }}library CompatibleERC20Functions { using Ox5cda3019fa30e31c07a3b7e5da4f3722f0d46526 for uint256; function safeTransfer(address token, address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b) internal { CompatibleERC20(token).Ox9e77ca043e23d4424170be471b4632d20f2d94d8(Oxdae921211bf3abdb04d206b007b12bc509c30330, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); require(previousReturnValue(), "Ox9e77ca043e23d4424170be471b4632d20f2d94d8 failed"); } function safeTransferFrom(address token, address Oxe28ad47fd58d856c08155914fa0e9ba758066f85, address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b) internal { CompatibleERC20(token).Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921(Oxe28ad47fd58d856c08155914fa0e9ba758066f85, Oxdae921211bf3abdb04d206b007b12bc509c30330, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); require(previousReturnValue(), "Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921 failed"); } function safeApprove(address token, address Oxece009e1b0e715e437b13b1aeb298afdc6b53902, uint256 Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b) internal { CompatibleERC20(token).Oxf13798447bf00e84147a365173f975f3f4bf6ff7(Oxece009e1b0e715e437b13b1aeb298afdc6b53902, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); require(previousReturnValue(), "Oxf13798447bf00e84147a365173f975f3f4bf6ff7 failed"); } function safeTransferFromWithFees(address token, address Oxe28ad47fd58d856c08155914fa0e9ba758066f85, address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b) internal returns (uint256) { uint256 balancesBefore = CompatibleERC20(token).Ox981c3635c7bf8e19934a068b4d2e04d0e20217d9(Oxdae921211bf3abdb04d206b007b12bc509c30330); CompatibleERC20(token).Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921(Oxe28ad47fd58d856c08155914fa0e9ba758066f85, Oxdae921211bf3abdb04d206b007b12bc509c30330, Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b); require(previousReturnValue(), "Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921 failed"); uint256 balancesAfter = CompatibleERC20(token).Ox981c3635c7bf8e19934a068b4d2e04d0e20217d9(Oxdae921211bf3abdb04d206b007b12bc509c30330); return Math.min256(Ox9aa6013812999eff1748bb1b04b7fd8cc8d67b2b, balancesAfter.Ox456a1e013a614f20a09c7da191fd08bf32fad494(balancesBefore)); } function previousReturnValue() private pure returns (bool) { uint256 returnData = 0; assembly { /* solium-disable-line security/no-inline-assembly */ switch returndatasize case 0 { returnData := 1 } case 32 { returndatacopy(0x0, 0x0, 32) returnData := mload(0x0) } default { } } return returnData != 0; }}interface CompatibleERC20 { function Ox9e77ca043e23d4424170be471b4632d20f2d94d8(address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577) external; function Oxb0710336ff5dbd53d8be67e1bf06b38ed8e3b921(address Oxe28ad47fd58d856c08155914fa0e9ba758066f85, address Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577) external; function Oxf13798447bf00e84147a365173f975f3f4bf6ff7(address Oxece009e1b0e715e437b13b1aeb298afdc6b53902, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577) external; function Ox7ac56db59149c295858d2cbddb2db0cacef3d2d4() external view returns (uint256); function Ox981c3635c7bf8e19934a068b4d2e04d0e20217d9(address who) external view returns (uint256); function Oxdbf027617a5f9f95a6154f1d5fad38090fb28c95(address Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, address Oxece009e1b0e715e437b13b1aeb298afdc6b53902) external view returns (uint256); event Transfer(address indexed Oxe28ad47fd58d856c08155914fa0e9ba758066f85, address indexed Oxdae921211bf3abdb04d206b007b12bc509c30330, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577); event Approval(address indexed Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704, address indexed Oxece009e1b0e715e437b13b1aeb298afdc6b53902, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577);}contract DarknodeRewardVault is Ownable { using Ox5cda3019fa30e31c07a3b7e5da4f3722f0d46526 for uint256; using CompatibleERC20Functions for CompatibleERC20; DarknodeRegistry public darknodeRegistry; mapping(address => mapping(address => uint256)) public darknodeBalances; event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry); constructor(string _VERSION, DarknodeRegistry _darknodeRegistry) public { VERSION = _VERSION; darknodeRegistry = _darknodeRegistry; } function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) public Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry); darknodeRegistry = _newDarknodeRegistry; } function deposit(address _darknode, ERC20 Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) public payable { uint256 receivedValue = Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6; if (address(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) == s2c.ETHEREUM) { require(msg.Ox8c41d7c2a90735aca36d993c6db992ee1b858577 == Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6, "mismatched ether Ox8c41d7c2a90735aca36d993c6db992ee1b858577"); } else { require(msg.Ox8c41d7c2a90735aca36d993c6db992ee1b858577 == 0, "unexpected ether Ox8c41d7c2a90735aca36d993c6db992ee1b858577"); receivedValue = CompatibleERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d).safeTransferFromWithFees(msg.sender, address(this), Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } darknodeBalances[_darknode][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] = darknodeBalances[_darknode][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d].Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(receivedValue); } function withdraw(address _darknode, ERC20 Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) public { address darknodeOwner = darknodeRegistry.getDarknodeOwner(address(_darknode)); require(darknodeOwner != 0x0, "invalid darknode Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704"); uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577 = darknodeBalances[_darknode][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d]; darknodeBalances[_darknode][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] = 0; if (address(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) == s2c.ETHEREUM) { darknodeOwner.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(Ox8c41d7c2a90735aca36d993c6db992ee1b858577); } else { CompatibleERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d).safeTransfer(darknodeOwner, Ox8c41d7c2a90735aca36d993c6db992ee1b858577); } }}interface BrokerVerifier { function verifyOpenSignature( address _trader, bytes _signature, bytes32 _orderID ) external returns (bool);}interface Settlement { function submitOrder( bytes _details, uint64 _settlementID, uint64 _tokens, uint256 _price, uint256 _volume, uint256 _minimumVolume ) external; function submissionGasPriceLimit() external view returns (uint256); function settle( bytes32 _buyID, bytes32 _sellID ) external; function orderStatus(bytes32 _orderID) external view returns (uint8);}contract SettlementRegistry is Ownable { struct SettlementDetails { bool registered; Settlement settlementContract; BrokerVerifier brokerVerifierContract; } mapping(uint64 => SettlementDetails) public settlementDetails; event LogSettlementRegistered(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract); event LogSettlementUpdated(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract); event LogSettlementDeregistered(uint64 settlementID); constructor(string _VERSION) public { VERSION = _VERSION; } function settlementRegistration(uint64 _settlementID) external view returns (bool) { return settlementDetails[_settlementID].registered; } function settlementContract(uint64 _settlementID) external view returns (Settlement) { return settlementDetails[_settlementID].settlementContract; } function brokerVerifierContract(uint64 _settlementID) external view returns (BrokerVerifier) { return settlementDetails[_settlementID].brokerVerifierContract; } function registerSettlement(uint64 _settlementID, Settlement _settlementContract, BrokerVerifier _brokerVerifierContract) public Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { bool alreadyRegistered = settlementDetails[_settlementID].registered; settlementDetails[_settlementID] = SettlementDetails({ registered: true, settlementContract: _settlementContract, brokerVerifierContract: _brokerVerifierContract }); if (alreadyRegistered) { emit LogSettlementUpdated(_settlementID, _settlementContract, _brokerVerifierContract); } else { emit LogSettlementRegistered(_settlementID, _settlementContract, _brokerVerifierContract); } } function deregisterSettlement(uint64 _settlementID) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { require(settlementDetails[_settlementID].registered, "not registered"); delete settlementDetails[_settlementID]; emit LogSettlementDeregistered(_settlementID); }}/** * @title Eliptic curve signature operations * @dev Based on https: * TODO Remove this library once solidity supports passing Oxd56f0da56258478530c68b005f8751eef529708f signature Oxdae921211bf3abdb04d206b007b12bc509c30330 ecrecover. * See https: */library ECRecovery { /** * @dev Recover signer address Oxe28ad47fd58d856c08155914fa0e9ba758066f85 Oxd56f0da56258478530c68b005f8751eef529708f message by using their signature * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address. * @param sig bytes signature, the signature is generated using web3.eth.sign() */ function recover(bytes32 hash, bytes sig) internal pure returns (address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) { return (address(0)); } assembly { r := mload(Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(sig, 32)) s := mload(Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(sig, 64)) v := byte(0, mload(Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(sig, 96))) } if (v < 27) { v += 27; } if (v != 27 && v != 28) { return (address(0)); } else { return ecrecover(hash, v, r, s); } } /** * toEthSignedMessageHash * @dev prefix Oxd56f0da56258478530c68b005f8751eef529708f bytes32 Ox8c41d7c2a90735aca36d993c6db992ee1b858577 with "\x19Ethereum Signed Message:" * and hash the result */ function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) { return keccak256( abi.encodePacked("\x19Ethereum Signed Message:\n32", hash) ); }}library Utils { /** * @notice Converts Oxd56f0da56258478530c68b005f8751eef529708f number Oxdae921211bf3abdb04d206b007b12bc509c30330 its string/bytes representation * * @param _v the uint Oxdae921211bf3abdb04d206b007b12bc509c30330 convert */ function uintToBytes(uint256 _v) internal pure returns (bytes) { uint256 v = _v; if (v == 0) { return "0"; } uint256 digits = 0; uint256 v2 = v; while (v2 > 0) { v2 /= 10; digits += 1; } bytes memory result = new bytes(digits); for (uint256 i = 0; i < digits; i++) { result[digits - i - 1] = bytes1((v % 10) + 48); v /= 10; } return result; } /** * @notice Retrieves the address Oxe28ad47fd58d856c08155914fa0e9ba758066f85 Oxd56f0da56258478530c68b005f8751eef529708f signature * * @param _hash the message that was signed (any length of bytes) * @param _signature the signature (65 bytes) */ function addr(bytes _hash, bytes _signature) internal pure returns (address) { bytes memory prefix = "\x19Ethereum Signed Message:\n"; bytes memory encoded = abi.encodePacked(prefix, uintToBytes(_hash.length), _hash); bytes32 prefixedHash = keccak256(encoded); return ECRecovery.recover(prefixedHash, _signature); }}contract Orderbook is Ownable { enum OrderState {Undefined, Open, Confirmed, Canceled} struct Order { OrderState state; address trader; address confirmer; uint64 settlementID; uint256 priority; uint256 blockNumber; bytes32 matchedOrder; } DarknodeRegistry public darknodeRegistry; SettlementRegistry public settlementRegistry; bytes32[] private orderbook; mapping(bytes32 => Order) public orders; event LogFeeUpdated(uint256 previousFee, uint256 nextFee); event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry); modifier onlyDarknode(address _sender) { require(darknodeRegistry.isRegistered(address(_sender)), "must be registered darknode"); _; } constructor( string _VERSION, DarknodeRegistry _darknodeRegistry, SettlementRegistry _settlementRegistry ) public { VERSION = _VERSION; darknodeRegistry = _darknodeRegistry; settlementRegistry = _settlementRegistry; } function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry); darknodeRegistry = _newDarknodeRegistry; } function openOrder(uint64 _settlementID, bytes _signature, bytes32 _orderID) external { require(orders[_orderID].state == OrderState.Undefined, "invalid order status"); address trader = msg.sender; require(settlementRegistry.settlementRegistration(_settlementID), "settlement not registered"); BrokerVerifier brokerVerifier = settlementRegistry.brokerVerifierContract(_settlementID); require(brokerVerifier.verifyOpenSignature(trader, _signature, _orderID), "invalid broker signature"); orders[_orderID] = Order({ state: OrderState.Open, trader: trader, confirmer: 0x0, settlementID: _settlementID, priority: orderbook.length + 1, blockNumber: block.number, matchedOrder: 0x0 }); orderbook.push(_orderID); } function confirmOrder(bytes32 _orderID, bytes32 _matchedOrderID) external onlyDarknode(msg.sender) { require(orders[_orderID].state == OrderState.Open, "invalid order status"); require(orders[_matchedOrderID].state == OrderState.Open, "invalid order status"); orders[_orderID].state = OrderState.Confirmed; orders[_orderID].confirmer = msg.sender; orders[_orderID].matchedOrder = _matchedOrderID; orders[_orderID].blockNumber = block.number; orders[_matchedOrderID].state = OrderState.Confirmed; orders[_matchedOrderID].confirmer = msg.sender; orders[_matchedOrderID].matchedOrder = _orderID; orders[_matchedOrderID].blockNumber = block.number; } function cancelOrder(bytes32 _orderID) external { require(orders[_orderID].state == OrderState.Open, "invalid order state"); address brokerVerifier = address(settlementRegistry.brokerVerifierContract(orders[_orderID].settlementID)); require(msg.sender == orders[_orderID].trader || msg.sender == brokerVerifier, "not authorized"); orders[_orderID].state = OrderState.Canceled; orders[_orderID].blockNumber = block.number; } function orderState(bytes32 _orderID) external view returns (OrderState) { return orders[_orderID].state; } function orderMatch(bytes32 _orderID) external view returns (bytes32) { return orders[_orderID].matchedOrder; } function orderPriority(bytes32 _orderID) external view returns (uint256) { return orders[_orderID].priority; } function orderTrader(bytes32 _orderID) external view returns (address) { return orders[_orderID].trader; } function orderConfirmer(bytes32 _orderID) external view returns (address) { return orders[_orderID].confirmer; } function orderBlockNumber(bytes32 _orderID) external view returns (uint256) { return orders[_orderID].blockNumber; } function orderDepth(bytes32 _orderID) external view returns (uint256) { if (orders[_orderID].blockNumber == 0) { return 0; } return (block.number - orders[_orderID].blockNumber); } function ordersCount() external view returns (uint256) { return orderbook.length; } function getOrders(uint256 _offset, uint256 _limit) external view returns (bytes32[], address[], uint8[]) { if (_offset >= orderbook.length) { return; } uint256 limit = _limit; if (_offset + limit > orderbook.length) { limit = orderbook.length - _offset; } bytes32[] memory orderIDs = new bytes32[](limit); address[] memory traderAddresses = new address[](limit); uint8[] memory states = new uint8[](limit); for (uint256 i = 0; i < limit; i++) { bytes32 order = orderbook[i + _offset]; orderIDs[i] = order; traderAddresses[i] = orders[order].trader; states[i] = uint8(orders[order].state); } return (orderIDs, traderAddresses, states); }}library SettlementUtils { struct OrderDetails { uint64 settlementID; uint64 tokens; uint256 price; uint256 volume; uint256 minimumVolume; } function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) { return keccak256( abi.encodePacked( details, order.settlementID, order.tokens, order.price, order.volume, order.minimumVolume ) ); } function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) { if (!verifyTokens(_buy.tokens, _sell.tokens)) { return false; } if (_buy.price < _sell.price) { return false; } if (_buy.volume < _sell.minimumVolume) { return false; } if (_sell.volume < _buy.minimumVolume) { return false; } if (_buy.settlementID != _sell.settlementID) { return false; } return true; } function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) { return (( uint32(_buyTokens) == uint32(_sellToken >> 32)) && ( uint32(_sellToken) == uint32(_buyTokens >> 32)) && ( uint32(_buyTokens >> 32) <= uint32(_buyTokens)) ); }}contract RenExTokens is Ownable { struct TokenDetails { address addr; uint8 Ox97403ffef8701ac621cbb41be529b4451f71ee94; bool registered; } mapping(uint32 => TokenDetails) public tokens; mapping(uint32 => bool) private detailsSubmitted; event LogTokenRegistered(uint32 tokenCode, address tokenAddress, uint8 tokenDecimals); event LogTokenDeregistered(uint32 tokenCode); constructor(string _VERSION) public { VERSION = _VERSION; } function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { require(!tokens[_tokenCode].registered, "already registered"); if (detailsSubmitted[_tokenCode]) { require(tokens[_tokenCode].addr == _tokenAddress, "different address"); require(tokens[_tokenCode].Ox97403ffef8701ac621cbb41be529b4451f71ee94 == _tokenDecimals, "different Ox97403ffef8701ac621cbb41be529b4451f71ee94"); } else { detailsSubmitted[_tokenCode] = true; } tokens[_tokenCode] = TokenDetails({ addr: _tokenAddress, Ox97403ffef8701ac621cbb41be529b4451f71ee94: _tokenDecimals, registered: true }); emit LogTokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals); } function deregisterToken(uint32 _tokenCode) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { require(tokens[_tokenCode].registered, "not registered"); tokens[_tokenCode].registered = false; emit LogTokenDeregistered(_tokenCode); }}contract RenExSettlement is Ownable { using Ox5cda3019fa30e31c07a3b7e5da4f3722f0d46526 for uint256; Orderbook public orderbookContract; RenExTokens public renExTokensContract; RenExBalances public renExBalancesContract; enum OrderStatus {None, Submitted, Settled, Slashed} struct TokenPair { RenExTokens.TokenDetails priorityToken; RenExTokens.TokenDetails secondaryToken; } struct ValueWithFees { uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577; uint256 fees; } struct Fraction { uint256 numerator; uint256 denominator; } struct SettlementDetails { uint256 leftVolume; uint256 rightVolume; uint256 leftTokenFee; uint256 rightTokenFee; address leftTokenAddress; address rightTokenAddress; } event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook); event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens); event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances); event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit); event LogSlasherUpdated(address previousSlasher, address nextSlasher); mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails; mapping(bytes32 => address) public orderSubmitter; mapping(bytes32 => OrderStatus) public orderStatus; mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp; modifier withGasPriceLimit(uint256 _gasPriceLimit) { require(tx.gasprice <= _gasPriceLimit, "gas price too high"); _; } modifier onlySlasher() { require(msg.sender == s2c.slasherAddress, "unauthorized"); _; } constructor( string _VERSION, Orderbook _orderbookContract, RenExTokens _renExTokensContract, RenExBalances _renExBalancesContract, address _slasherAddress, uint256 _submissionGasPriceLimit ) public { VERSION = _VERSION; orderbookContract = _orderbookContract; renExTokensContract = _renExTokensContract; renExBalancesContract = _renExBalancesContract; s2c.slasherAddress = _slasherAddress; s2c.submissionGasPriceLimit = _submissionGasPriceLimit; } function updateOrderbook(Orderbook _newOrderbookContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract); orderbookContract = _newOrderbookContract; } function updateRenExTokens(RenExTokens _newRenExTokensContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract); renExTokensContract = _newRenExTokensContract; } function updateRenExBalances(RenExBalances _newRenExBalancesContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract); renExBalancesContract = _newRenExBalancesContract; } function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogSubmissionGasPriceLimitUpdated(s2c.submissionGasPriceLimit, _newSubmissionGasPriceLimit); s2c.submissionGasPriceLimit = _newSubmissionGasPriceLimit; } function updateSlasher(address _newSlasherAddress) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogSlasherUpdated(s2c.slasherAddress, _newSlasherAddress); s2c.slasherAddress = _newSlasherAddress; } function submitOrder( bytes _prefix, uint64 _settlementID, uint64 _tokens, uint256 _price, uint256 _volume, uint256 _minimumVolume ) external withGasPriceLimit(s2c.submissionGasPriceLimit) { SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({ settlementID: _settlementID, tokens: _tokens, price: _price, volume: _volume, minimumVolume: _minimumVolume }); bytes32 orderID = SettlementUtils.hashOrder(_prefix, order); require(orderStatus[orderID] == OrderStatus.None, "order already submitted"); require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, "unconfirmed order"); orderSubmitter[orderID] = msg.sender; orderStatus[orderID] = OrderStatus.Submitted; orderDetails[orderID] = order; } function settle(bytes32 _buyID, bytes32 _sellID) external { require(orderStatus[_buyID] == OrderStatus.Submitted, "invalid Ox82699f3d74a03aadcbb5e4dc8af2c54b3424c97e status"); require(orderStatus[_sellID] == OrderStatus.Submitted, "invalid sell status"); require( orderDetails[_buyID].settlementID == s2c.RENEX_ATOMIC_SETTLEMENT_ID || orderDetails[_buyID].settlementID == s2c.RENEX_SETTLEMENT_ID, "invalid settlement id" ); require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), "incompatible orders"); require(orderbookContract.orderMatch(_buyID) == _sellID, "unconfirmed orders"); TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens); require(tokens.priorityToken.registered, "unregistered priority token"); require(tokens.secondaryToken.registered, "unregistered secondary token"); address buyer = orderbookContract.orderTrader(_buyID); address seller = orderbookContract.orderTrader(_sellID); require(buyer != seller, "orders Oxe28ad47fd58d856c08155914fa0e9ba758066f85 same trader"); execute(_buyID, _sellID, buyer, seller, tokens); /* solium-disable-next-line security/no-block-members */ matchTimestamp[_buyID][_sellID] = now; orderStatus[_buyID] = OrderStatus.Settled; orderStatus[_sellID] = OrderStatus.Settled; } function slash(bytes32 _guiltyOrderID) external onlySlasher { require(orderDetails[_guiltyOrderID].settlementID == s2c.RENEX_ATOMIC_SETTLEMENT_ID, "slashing non-atomic trade"); bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID); require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, "invalid order status"); require(orderStatus[innocentOrderID] == OrderStatus.Settled, "invalid order status"); orderStatus[_guiltyOrderID] = OrderStatus.Slashed; (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID); TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens); SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens); renExBalancesContract.transferBalanceWithFee( orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0 ); renExBalancesContract.transferBalanceWithFee( orderbookContract.orderTrader(_guiltyOrderID), s2c.slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0 ); } function getMatchDetails(bytes32 _orderID) external view returns ( bool settled, bool orderIsBuy, bytes32 matchedID, uint256 priorityVolume, uint256 secondaryVolume, uint256 priorityFee, uint256 secondaryFee, uint32 priorityToken, uint32 secondaryToken ) { matchedID = orderbookContract.orderMatch(_orderID); orderIsBuy = isBuyOrder(_orderID); (bytes32 buyID, bytes32 sellID) = orderIsBuy ? (_orderID, matchedID) : (matchedID, _orderID); SettlementDetails memory settlementDetails = calculateSettlementDetails( buyID, sellID, getTokenDetails(orderDetails[buyID].tokens) ); return ( orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed, orderIsBuy, matchedID, settlementDetails.leftVolume, settlementDetails.rightVolume, settlementDetails.leftTokenFee, settlementDetails.rightTokenFee, uint32(orderDetails[buyID].tokens >> 32), uint32(orderDetails[buyID].tokens) ); } function hashOrder( bytes _prefix, uint64 _settlementID, uint64 _tokens, uint256 _price, uint256 _volume, uint256 _minimumVolume ) external pure returns (bytes32) { return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({ settlementID: _settlementID, tokens: _tokens, price: _price, volume: _volume, minimumVolume: _minimumVolume })); } function execute( bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens ) private { SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == s2c.RENEX_ATOMIC_SETTLEMENT_ID) ? settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) : settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens); renExBalancesContract.transferBalanceWithFee( _buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID] ); renExBalancesContract.transferBalanceWithFee( _seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID] ); } function calculateSettlementDetails( bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens ) private view returns (SettlementDetails memory) { Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2); uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume); uint256 priorityTokenVolume = joinFraction( commonVolume.Oxa1df55cf732334edf7ee1c6f99208cbba72f31c4(midPrice.numerator), midPrice.denominator, int16(_tokens.priorityToken.Ox97403ffef8701ac621cbb41be529b4451f71ee94) - s2c.PRICE_OFFSET - s2c.VOLUME_OFFSET ); uint256 secondaryTokenVolume = joinFraction( commonVolume, 1, int16(_tokens.secondaryToken.Ox97403ffef8701ac621cbb41be529b4451f71ee94) - s2c.VOLUME_OFFSET ); ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume); ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume); return SettlementDetails({ leftVolume: priorityVwF.Ox8c41d7c2a90735aca36d993c6db992ee1b858577, rightVolume: secondaryVwF.Ox8c41d7c2a90735aca36d993c6db992ee1b858577, leftTokenFee: priorityVwF.fees, rightTokenFee: secondaryVwF.fees, leftTokenAddress: _tokens.priorityToken.addr, rightTokenAddress: _tokens.secondaryToken.addr }); } function calculateAtomicFees( bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens ) private view returns (SettlementDetails memory) { Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2); uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume); if (isEthereumBased(_tokens.secondaryToken.addr)) { uint256 secondaryTokenVolume = joinFraction( commonVolume, 1, int16(_tokens.secondaryToken.Ox97403ffef8701ac621cbb41be529b4451f71ee94) - s2c.VOLUME_OFFSET ); ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume); return SettlementDetails({ leftVolume: 0, rightVolume: 0, leftTokenFee: secondaryVwF.fees, rightTokenFee: secondaryVwF.fees, leftTokenAddress: _tokens.secondaryToken.addr, rightTokenAddress: _tokens.secondaryToken.addr }); } else if (isEthereumBased(_tokens.priorityToken.addr)) { uint256 priorityTokenVolume = joinFraction( commonVolume.Oxa1df55cf732334edf7ee1c6f99208cbba72f31c4(midPrice.numerator), midPrice.denominator, int16(_tokens.priorityToken.Ox97403ffef8701ac621cbb41be529b4451f71ee94) - s2c.PRICE_OFFSET - s2c.VOLUME_OFFSET ); ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume); return SettlementDetails({ leftVolume: 0, rightVolume: 0, leftTokenFee: priorityVwF.fees, rightTokenFee: priorityVwF.fees, leftTokenAddress: _tokens.priorityToken.addr, rightTokenAddress: _tokens.priorityToken.addr }); } else { revert("non-eth atomic swaps are not supported"); } } function isBuyOrder(bytes32 _orderID) private view returns (bool) { uint64 tokens = orderDetails[_orderID].tokens; uint32 firstToken = uint32(tokens >> 32); uint32 secondaryToken = uint32(tokens); return (firstToken < secondaryToken); } function subtractDarknodeFee(uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) private pure returns (ValueWithFees memory) { uint256 newValue = (Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 * (s2c.DARKNODE_FEES_DENOMINATOR - s2c.DARKNODE_FEES_NUMERATOR)) / s2c.DARKNODE_FEES_DENOMINATOR; return ValueWithFees(newValue, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 - newValue); } function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) { ( address priorityAddress, uint8 priorityDecimals, bool priorityRegistered ) = renExTokensContract.tokens(uint32(_tokens >> 32)); ( address secondaryAddress, uint8 secondaryDecimals, bool secondaryRegistered ) = renExTokensContract.tokens(uint32(_tokens)); return TokenPair({ priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered), secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered) }); } function isEthereumBased(address _tokenAddress) private pure returns (bool) { return (_tokenAddress != address(0x0)); } function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) { if (_scale >= 0) { assert(_scale <= 77); return _numerator.Oxa1df55cf732334edf7ee1c6f99208cbba72f31c4(10 ** uint256(_scale)) / _denominator; } else { return (_numerator / _denominator) / 10 ** uint256(-_scale); } }}contract RenExBrokerVerifier is Ownable { event LogBalancesContractUpdated(address previousBalancesContract, address nextBalancesContract); event LogBrokerRegistered(address broker); event LogBrokerDeregistered(address broker); mapping(address => bool) public brokers; mapping(address => uint256) public traderNonces; modifier onlyBalancesContract() { require(msg.sender == s2c.balancesContract, "not authorized"); _; } constructor(string _VERSION) public { VERSION = _VERSION; } function updateBalancesContract(address _balancesContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogBalancesContractUpdated(s2c.balancesContract, _balancesContract); s2c.balancesContract = _balancesContract; } function registerBroker(address _broker) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { require(!brokers[_broker], "already registered"); brokers[_broker] = true; emit LogBrokerRegistered(_broker); } function deregisterBroker(address _broker) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { require(brokers[_broker], "not registered"); brokers[_broker] = false; emit LogBrokerDeregistered(_broker); } function verifyOpenSignature( address _trader, bytes _signature, bytes32 _orderID ) external view returns (bool) { bytes memory data = abi.encodePacked("Republic Protocol: open: ", _trader, _orderID); address signer = Utils.addr(data, _signature); return (brokers[signer] == true); } function verifyWithdrawSignature( address _trader, bytes _signature ) external onlyBalancesContract returns (bool) { bytes memory data = abi.encodePacked("Republic Protocol: withdraw: ", _trader, traderNonces[_trader]); address signer = Utils.addr(data, _signature); if (brokers[signer]) { traderNonces[_trader] += 1; return true; } return false; }}contract RenExBalances is Ownable { using Ox5cda3019fa30e31c07a3b7e5da4f3722f0d46526 for uint256; using CompatibleERC20Functions for CompatibleERC20; RenExSettlement public settlementContract; RenExBrokerVerifier public brokerVerifierContract; DarknodeRewardVault public rewardVaultContract; event LogBalanceDecreased(address trader, ERC20 token, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577); event LogBalanceIncreased(address trader, ERC20 token, uint256 Ox8c41d7c2a90735aca36d993c6db992ee1b858577); event LogRenExSettlementContractUpdated(address previousRenExSettlementContract, address newRenExSettlementContract); event LogRewardVaultContractUpdated(address previousRewardVaultContract, address newRewardVaultContract); event LogBrokerVerifierContractUpdated(address previousBrokerVerifierContract, address newBrokerVerifierContract); mapping(address => mapping(address => uint256)) public traderBalances; mapping(address => mapping(address => uint256)) public traderWithdrawalSignals; constructor( string _VERSION, DarknodeRewardVault _rewardVaultContract, RenExBrokerVerifier _brokerVerifierContract ) public { VERSION = _VERSION; rewardVaultContract = _rewardVaultContract; brokerVerifierContract = _brokerVerifierContract; } modifier onlyRenExSettlementContract() { require(msg.sender == address(settlementContract), "not authorized"); _; } modifier withBrokerSignatureOrSignal(address Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, bytes _signature) { address trader = msg.sender; if (_signature.length > 0) { require (brokerVerifierContract.verifyWithdrawSignature(trader, _signature), "invalid signature"); } else { require(traderWithdrawalSignals[trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] != 0, "not signalled"); /* solium-disable-next-line security/no-block-members */ require((now - traderWithdrawalSignals[trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d]) > s2c.SIGNAL_DELAY, "signal time remaining"); traderWithdrawalSignals[trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] = 0; } _; } function updateRenExSettlementContract(RenExSettlement _newSettlementContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogRenExSettlementContractUpdated(settlementContract, _newSettlementContract); settlementContract = _newSettlementContract; } function updateRewardVaultContract(DarknodeRewardVault _newRewardVaultContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogRewardVaultContractUpdated(rewardVaultContract, _newRewardVaultContract); rewardVaultContract = _newRewardVaultContract; } function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external Ox6bcfcf415d66bc7b0776d95057b378f6d7c1b806 { emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract); brokerVerifierContract = _newBrokerVerifierContract; } function transferBalanceWithFee(address _traderFrom, address _traderTo, address Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6, uint256 _fee, address _feePayee) external onlyRenExSettlementContract { require(traderBalances[_traderFrom][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] >= _fee, "insufficient funds for fee"); if (address(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) == ETHEREUM) { rewardVaultContract.deposit.Ox8c41d7c2a90735aca36d993c6db992ee1b858577(_fee)(_feePayee, ERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d), _fee); } else { CompatibleERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d).safeApprove(rewardVaultContract, _fee); rewardVaultContract.deposit(_feePayee, ERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d), _fee); } privateDecrementBalance(_traderFrom, ERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d), Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 + _fee); if (Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6 > 0) { privateIncrementBalance(_traderTo, ERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d), Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } } function deposit(ERC20 Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) external payable { address trader = msg.sender; uint256 receivedValue = Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6; if (address(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) == ETHEREUM) { require(msg.Ox8c41d7c2a90735aca36d993c6db992ee1b858577 == Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6, "mismatched Ox8c41d7c2a90735aca36d993c6db992ee1b858577 parameter and tx Ox8c41d7c2a90735aca36d993c6db992ee1b858577"); } else { require(msg.Ox8c41d7c2a90735aca36d993c6db992ee1b858577 == 0, "unexpected ether Ox9e77ca043e23d4424170be471b4632d20f2d94d8"); receivedValue = CompatibleERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d).safeTransferFromWithFees(trader, this, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } privateIncrementBalance(trader, Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, receivedValue); } function withdraw(ERC20 Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6, bytes _signature) external withBrokerSignatureOrSignal(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, _signature) { address trader = msg.sender; privateDecrementBalance(trader, Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); if (address(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) == ETHEREUM) { trader.Ox9e77ca043e23d4424170be471b4632d20f2d94d8(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } else { CompatibleERC20(Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d).safeTransfer(trader, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } } function signalBackupWithdraw(address Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d) external { /* solium-disable-next-line security/no-block-members */ traderWithdrawalSignals[msg.sender][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] = now; } function privateIncrementBalance(address _trader, ERC20 Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) private { traderBalances[_trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] = traderBalances[_trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d].Ox1a15d3cd9fd80f381faf3295370bb5b075011d88(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); emit LogBalanceIncreased(_trader, Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); } function privateDecrementBalance(address _trader, ERC20 Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, uint256 Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6) private { require(traderBalances[_trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] >= Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6, "insufficient funds"); traderBalances[_trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d] = traderBalances[_trader][Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d].Ox456a1e013a614f20a09c7da191fd08bf32fad494(Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); emit LogBalanceDecreased(_trader, Ox4d8f867b321c6d9c34506e5ad809d784bbd6383d, Ox6fa5ded302a4ccc8f65c2ad506614d29dfb5b6c6); }struct scalar2Vector {uint256 SIGNAL_DELAY;address ETHEREUM;string VERSION;address balancesContract;string VERSION;uint256 submissionGasPriceLimit;address slasherAddress;int16 VOLUME_OFFSET;int16 PRICE_OFFSET;uint256 DARKNODE_FEES_DENOMINATOR;uint256 DARKNODE_FEES_NUMERATOR;uint32 RENEX_ATOMIC_SETTLEMENT_ID;uint32 RENEX_SETTLEMENT_ID;string VERSION;string VERSION;string VERSION;string VERSION;address ETHEREUM;string VERSION;address nextSlasher;uint256 nextMinimumEpochInterval;uint256 nextMinimumPodSize;uint256 nextMinimumBond;address slasher;uint256 minimumEpochInterval;uint256 minimumPodSize;uint256 minimumBond;uint256 numDarknodesPreviousEpoch;uint256 numDarknodesNextEpoch;uint256 numDarknodes;string VERSION;string VERSION;address NULL;uint256 INITIAL_SUPPLY;uint8 Ox97403ffef8701ac621cbb41be529b4451f71ee94;string Ox088061391af67c0c5c2fcb1abe5238d01fe5adad;string Ox39258cac0c2cd700072f6d7e8120ed68b195f91f;bool paused;uint256 totalSupply_;address Ox19b0b3bb02752ecc8d76a2e90ce5b36dc894b704;}scalar2Vector s2c = scalar2Vector( 48 hours, address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), , address(0), , 0, address(0), 12, 12, 1000, 2, 2, 1, , , , , 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, , address(0), 0, 0, 0, address(0), 0, 0, 0, 0, 0, 0, , , 0x0, 1000000000 * 10**uint256(Ox97403ffef8701ac621cbb41be529b4451f71ee94), 18, "REN", "Republic Token", false, 0, address(0));}