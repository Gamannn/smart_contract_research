pragma solidity ^0.4.24;library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a / _b; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; }}contract Ownable { event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e = msg.sender; } modifier Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967() { require(msg.sender == s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e); _; } function renounceOwnership() public Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 { emit OwnershipRenounced(s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e); s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e = address(0); } function transferOwnership(address _newOwner) public Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, _newOwner); s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e = _newOwner; }}contract Pausable is Ownable { event Pause(); event Unpause(); modifier whenNotPaused() { require(!s2c.paused); _; } modifier whenPaused() { require(s2c.paused); _; } function pause() public Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 whenNotPaused { s2c.paused = true; emit Pause(); } /** * @dev called by the Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e to unpause, returns to normal state */ function unpause() public Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 whenPaused { s2c.paused = false; emit Unpause(); }}/** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https: */contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68);}/** * @title ERC20 interface * @dev see https: */contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, address indexed spender, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 );}/** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */library SafeERC20 { function safeTransfer( ERC20Basic _token, address _to, uint256 _value ) internal { require(_token.transfer(_to, _value)); } function safeTransferFrom( ERC20 _token, address _from, address _to, uint256 _value ) internal { require(_token.transferFrom(_from, _to, _value)); } function safeApprove( ERC20 _token, address _spender, uint256 _value ) internal { require(_token.approve(_spender, _value)); }}interface IMonethaVoucher { /** * @dev Total number of vouchers in shared pool */ function totalInSharedPool() external view returns (uint256); /** * @dev Converts vouchers to equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei. * @param _value Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers (vouchers) to convert to Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei. */ function toWei(uint256 _value) external view returns (uint256); /** * @dev Converts Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei to equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers. * @param _value Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei to convert to vouchers (vouchers) * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers. */ function fromWei(uint256 _value) external view returns (uint256); /** * @dev Applies discount for address by returning vouchers to shared pool and transferring funds (in wei). May be called only by Monetha. * @param _for address to apply discount for * @param _vouchers Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to return to shared pool * @return Actual number of vouchers returned to shared pool and Ox39851aa46274526f2f7235cd0156854b88751ea6 of funds (in wei) transferred. */ function applyDiscount(address _for, uint256 _vouchers) external returns (uint256 amountVouchers, uint256 amountWei); /** * @dev Applies payback by transferring vouchers from the shared pool to the user. * The Ox39851aa46274526f2f7235cd0156854b88751ea6 of transferred vouchers is equivalent to the Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether in the `_amountWei` parameter. * @param _for address to apply payback for * @param _amountWei Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether to estimate the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers * @return The number of vouchers added */ function applyPayback(address _for, uint256 _amountWei) external returns (uint256 amountVouchers); /** * @dev Function to buy vouchers by transferring equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 in Ether to contract. May be called only by Monetha. * After the vouchers are purchased, they can be sold or released to another user. Purchased vouchers are stored in * a separate pool and may not be expired. * @param _vouchers The Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to buy. The caller must also transfer an equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether. */ function buyVouchers(uint256 _vouchers) external payable; /** * @dev The function allows Monetha account to sell previously purchased vouchers and get Ether from the sale. * The equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether will be transferred to the caller. May be called only by Monetha. * @param _vouchers The Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to sell. * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether (in wei) transferred to the caller. */ function sellVouchers(uint256 _vouchers) external returns(uint256 weis); /** * @dev Function allows Monetha account to release the purchased vouchers to any address. * The released voucher acquires an expiration property and should be used in Monetha ecosystem within 6 months, otherwise * it will be returned to shared pool. May be called only by Monetha. * @param _to address to release vouchers to. * @param _value the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to release. */ function releasePurchasedTo(address _to, uint256 _value) external returns (bool); /** * @dev Function to check the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers that an Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e (Monetha account) allowed to sell or release to some user. * @param Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e The address which owns the funds. * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers still available for the Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e. */ function purchasedBy(address Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e) external view returns (uint256);}/** @title Restricted * Exposes onlyMonetha modifier */contract Restricted is Ownable { event MonethaAddressSet( address _address, bool _isMonethaAddress ); mapping (address => bool) public isMonethaAddress; /** * Restrict methods in such way, that they can be invoked only by monethaAddress account. */ modifier onlyMonetha() { require(isMonethaAddress[msg.sender]); _; } /** * Allows Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e to set new monetha address */ function setMonethaAddress(address _address, bool _isMonethaAddress) Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 public { isMonethaAddress[_address] = _isMonethaAddress; emit MonethaAddressSet(_address, _isMonethaAddress); }}/** * @title ERC20 interface * @dev see https: */interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address who) external view returns (uint256); function allowance(address Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, address spender) external view returns (uint256); function transfer(address to, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68) external returns (bool); function approve(address spender, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68) external returns (bool); function transferFrom(address from, address to, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68); event Approval(address indexed Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, address indexed spender, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68);}contract CanReclaimEther is Ownable { event ReclaimEther(address indexed to, uint256 Ox39851aa46274526f2f7235cd0156854b88751ea6); /** * @dev Transfer all Ether held by the contract to the Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e. */ function reclaimEther() external Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 { uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 = address(this).Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2; s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e.transfer(Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68); emit ReclaimEther(s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68); } /** * @dev Transfer specified Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether held by the contract to the address. * @param _to The address which will receive the Ether * @param _value The Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether to transfer */ function reclaimEtherTo(address _to, uint256 _value) external Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 { require(_to != address(0), "zero address is not allowed"); _to.transfer(_value); emit ReclaimEther(_to, _value); }}contract CanReclaimTokens is Ownable { using SafeERC20 for ERC20Basic; event ReclaimTokens(address indexed to, uint256 Ox39851aa46274526f2f7235cd0156854b88751ea6); /** * @dev Reclaim all ERC20Basic compatible tokens * @param _token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic _token) external Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 { uint256 Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2 = _token.balanceOf(this); _token.safeTransfer(s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2); emit ReclaimTokens(s2c.Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2); } /** * @dev Reclaim specified Ox39851aa46274526f2f7235cd0156854b88751ea6 of ERC20Basic compatible tokens * @param _token ERC20Basic The address of the token contract * @param _to The address which will receive the tokens * @param _value The Ox39851aa46274526f2f7235cd0156854b88751ea6 of tokens to transfer */ function reclaimTokenTo(ERC20Basic _token, address _to, uint256 _value) external Ox56e1bfcfbdd180e33f76a48e58e8a88ee2d27967 { require(_to != address(0), "zero address is not allowed"); _token.safeTransfer(_to, _value); emit ReclaimTokens(_to, _value); }}contract MonethaVoucher is IMonethaVoucher, Restricted, Pausable, IERC20, CanReclaimEther, CanReclaimTokens { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event DiscountApplied(address indexed user, uint256 releasedVouchers, uint256 amountWeiTransferred); event PaybackApplied(address indexed user, uint256 addedVouchers, uint256 amountWeiEquivalent); event VouchersBought(address indexed user, uint256 vouchersBought); event VouchersSold(address indexed user, uint256 vouchersSold, uint256 amountWeiTransferred); event VoucherMthRateUpdated(uint256 oldVoucherMthRate, uint256 newVoucherMthRate); event MthEthRateUpdated(uint256 oldMthEthRate, uint256 newMthEthRate); event VouchersAdded(address indexed user, uint256 vouchersAdded); event VoucherReleased(address indexed user, uint256 releasedVoucher); event PurchasedVouchersReleased(address indexed from, address indexed to, uint256 vouchers); /* Public variables of the token */ /* For calculating half year */ s2c.DAY_IN_SECONDS s2c.DAY_IN_SECONDS s2c.YEAR_IN_SECONDS s2c.LEAP_YEAR_IN_SECONDS s2c.YEAR_IN_SECONDS_AVG s2c.RATE_COEFFICIENT s2c.RATE_COEFFICIENT ERC20Basic public mthToken; mapping(address => uint256) public purchased; mapping(uint16 => uint256) public totalDistributedIn; mapping(uint16 => mapping(address => uint256)) public distributed; constructor(uint256 _voucherMthRate, uint256 _mthEthRate, ERC20Basic _mthToken) public { require(_voucherMthRate > 0, "voucherMthRate should be greater than 0"); require(_mthEthRate > 0, "mthEthRate should be greater than 0"); require(_mthToken != address(0), "must be valid contract"); vs2c.voucherMthRate= _voucherMthRate; ms2c.mthEthRate= _mthEthRate; mthToken = _mthToken; _updateVoucherMthEthRate(); } /** * @dev Total number of vouchers in existence = vouchers in shared pool + vouchers distributed + vouchers purchased */ function totalSupply() external view returns (uint256) { return _totalVouchersSupply(); } /** * @dev Total number of vouchers in shared pool */ function totalInSharedPool() external view returns (uint256) { return _vouchersInSharedPool(_currentHalfYear()); } /** * @dev Total number of vouchers distributed */ function totalDistributed() external view returns (uint256) { return _vouchersDistributed(_currentHalfYear()); } /** * @dev Gets the Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2 of the specified address. * @param Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e The address to query the Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2 of. * @return An uint256 representing the Ox39851aa46274526f2f7235cd0156854b88751ea6 owned by the passed address. */ function balanceOf(address Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e) external view returns (uint256) { return _distributedTo(Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, _currentHalfYear()).add(purchased[Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e]); } /** * @dev Function to check the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers that an Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e allowed to a spender. * @param Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e address The address which owns the funds. * @param spender address The address which will spend the funds. * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers still available for the spender. */ function allowance(address Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e, address spender) external view returns (uint256) { Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e; spender; return 0; } /** * @dev Transfer voucher for a specified address * @param to The address to transfer to. * @param Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 The Ox39851aa46274526f2f7235cd0156854b88751ea6 to be transferred. */ function transfer(address to, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68) external returns (bool) { to; Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68; revert(); } /** * @dev Approve the passed address to spend the specified Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 afterwards: * https: * @param spender The address which will spend the funds. * @param Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 The Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to be spent. */ function approve(address spender, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68) external returns (bool) { spender; Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68; revert(); } /** * @dev Transfer vouchers from one address to another * @param from address The address which you want to send vouchers from * @param to address The address which you want to transfer to * @param Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 uint256 the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to be transferred */ function transferFrom(address from, address to, uint256 Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68) external returns (bool) { from; to; Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68; revert(); } function () external onlyMonetha payable { } /** * @dev Converts vouchers to equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei. * @param _value Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to convert to Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei. */ function toWei(uint256 _value) external view returns (uint256) { return _vouchersToWei(_value); } /** * @dev Converts Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei to equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers. * @param _value Ox39851aa46274526f2f7235cd0156854b88751ea6 of wei to convert to vouchers * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers. */ function fromWei(uint256 _value) external view returns (uint256) { return _weiToVouchers(_value); } /** * @dev Applies discount for address by returning vouchers to shared pool and transferring funds (in wei). May be called only by Monetha. * @param _for address to apply discount for * @param _vouchers Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to return to shared pool * @return Actual number of vouchers returned to shared pool and Ox39851aa46274526f2f7235cd0156854b88751ea6 of funds (in wei) transferred. */ function applyDiscount(address _for, uint256 _vouchers) external onlyMonetha returns (uint256 amountVouchers, uint256 amountWei) { require(_for != address(0), "zero address is not allowed"); uint256 releasedVouchers = _releaseVouchers(_for, _vouchers); if (releasedVouchers == 0) { return (0,0); } uint256 amountToTransfer = _vouchersToWei(releasedVouchers); require(address(this).Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2 >= amountToTransfer, "insufficient funds"); _for.transfer(amountToTransfer); emit DiscountApplied(_for, releasedVouchers, amountToTransfer); return (releasedVouchers, amountToTransfer); } /** * @dev Applies payback by transferring vouchers from the shared pool to the user. * The Ox39851aa46274526f2f7235cd0156854b88751ea6 of transferred vouchers is equivalent to the Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether in the `_amountWei` parameter. * @param _for address to apply payback for * @param _amountWei Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether to estimate the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers * @return The number of vouchers added */ function applyPayback(address _for, uint256 _amountWei) external onlyMonetha returns (uint256 amountVouchers) { amountVouchers = _weiToVouchers(_amountWei); require(_addVouchers(_for, amountVouchers), "vouchers must be added"); emit PaybackApplied(_for, amountVouchers, _amountWei); } /** * @dev Function to buy vouchers by transferring equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 in Ether to contract. May be called only by Monetha. * After the vouchers are purchased, they can be sold or released to another user. Purchased vouchers are stored in * a separate pool and may not be expired. * @param _vouchers The Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to buy. The caller must also transfer an equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether. */ function buyVouchers(uint256 _vouchers) external onlyMonetha payable { uint16 currentHalfYear = _currentHalfYear(); require(_vouchersInSharedPool(currentHalfYear) >= _vouchers, "insufficient vouchers present"); require(msg.Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68 == _vouchersToWei(_vouchers), "insufficient funds"); _addPurchasedTo(msg.sender, _vouchers); emit VouchersBought(msg.sender, _vouchers); } /** * @dev The function allows Monetha account to sell previously purchased vouchers and get Ether from the sale. * The equivalent Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether will be transferred to the caller. May be called only by Monetha. * @param _vouchers The Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to sell. * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of Ether (in wei) transferred to the caller. */ function sellVouchers(uint256 _vouchers) external onlyMonetha returns(uint256 weis) { require(_vouchers <= purchased[msg.sender], "Insufficient vouchers"); _subPurchasedFrom(msg.sender, _vouchers); weis = _vouchersToWei(_vouchers); msg.sender.transfer(weis); emit VouchersSold(msg.sender, _vouchers, weis); } /** * @dev Function allows Monetha account to release the purchased vouchers to any address. * The released voucher acquires an expiration property and should be used in Monetha ecosystem within 6 months, otherwise * it will be returned to shared pool. May be called only by Monetha. * @param _to address to release vouchers to. * @param _value the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to release. */ function releasePurchasedTo(address _to, uint256 _value) external onlyMonetha returns (bool) { require(_value <= purchased[msg.sender], "Insufficient Vouchers"); require(_to != address(0), "address should be valid"); _subPurchasedFrom(msg.sender, _value); _addVouchers(_to, _value); emit PurchasedVouchersReleased(msg.sender, _to, _value); return true; } /** * @dev Function to check the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers that an Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e (Monetha account) allowed to sell or release to some user. * @param Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e The address which owns the funds. * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers still available for the Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e. */ function purchasedBy(address Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e) external view returns (uint256) { return purchased[Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e]; } /** * @dev updates voucherMthRate. */ function updateVoucherMthRate(uint256 _voucherMthRate) external onlyMonetha { require(_voucherMthRate > 0, "should be greater than 0"); require(vs2c.voucherMthRate!= _voucherMthRate, "same as previous Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68"); vs2c.voucherMthRate= _voucherMthRate; _updateVoucherMthEthRate(); emit VoucherMthRateUpdated(vs2c.voucherMthRate _voucherMthRate); } /** * @dev updates mthEthRate. */ function updateMthEthRate(uint256 _mthEthRate) external onlyMonetha { require(_mthEthRate > 0, "should be greater than 0"); require(ms2c.mthEthRate!= _mthEthRate, "same as previous Oxc8d5ca9d23e304e5545e05ba1e147c6edf3aae68"); ms2c.mthEthRate= _mthEthRate; _updateVoucherMthEthRate(); emit MthEthRateUpdated(ms2c.mthEthRate _mthEthRate); } function _addPurchasedTo(address _to, uint256 _value) internal { purchased[_to] = purchased[_to].add(_value); ts2c.totalPurchased= ts2c.totalPurchasedadd(_value); } function _subPurchasedFrom(address _from, uint256 _value) internal { purchased[_from] = purchased[_from].sub(_value); ts2c.totalPurchased= ts2c.totalPurchasedsub(_value); } function _updateVoucherMthEthRate() internal { vs2c.voucherMthEthRate= vs2c.voucherMthRatemul(ms2c.mthEthRate; } /** * @dev Transfer vouchers from shared pool to address. May be called only by Monetha. * @param _to The address to transfer to. * @param _value The Ox39851aa46274526f2f7235cd0156854b88751ea6 to be transferred. */ function _addVouchers(address _to, uint256 _value) internal returns (bool) { require(_to != address(0), "zero address is not allowed"); uint16 currentHalfYear = _currentHalfYear(); require(_vouchersInSharedPool(currentHalfYear) >= _value, "must be less or equal than vouchers present in shared pool"); uint256 oldDist = totalDistributedIn[currentHalfYear]; totalDistributedIn[currentHalfYear] = oldDist.add(_value); uint256 oldBalance = distributed[currentHalfYear][_to]; distributed[currentHalfYear][_to] = oldBalance.add(_value); emit VouchersAdded(_to, _value); return true; } /** * @dev Transfer vouchers from address to shared pool * @param _from address The address which you want to send vouchers from * @param _value uint256 the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers to be transferred * @return A uint256 specifying the Ox39851aa46274526f2f7235cd0156854b88751ea6 of vouchers released to shared pool. */ function _releaseVouchers(address _from, uint256 _value) internal returns (uint256) { require(_from != address(0), "must be valid address"); uint16 currentHalfYear = _currentHalfYear(); uint256 released = 0; if (currentHalfYear > 0) { released = released.add(_releaseVouchers(_from, _value, currentHalfYear - 1)); _value = _value.sub(released); } released = released.add(_releaseVouchers(_from, _value, currentHalfYear)); emit VoucherReleased(_from, released); return released; } function _releaseVouchers(address _from, uint256 _value, uint16 _currentHalfYear) internal returns (uint256) { if (_value == 0) { return 0; } uint256 oldBalance = distributed[_currentHalfYear][_from]; uint256 subtracted = _value; if (oldBalance <= _value) { delete distributed[_currentHalfYear][_from]; subtracted = oldBalance; } else { distributed[_currentHalfYear][_from] = oldBalance.sub(_value); } uint256 oldDist = totalDistributedIn[_currentHalfYear]; if (oldDist == subtracted) { delete totalDistributedIn[_currentHalfYear]; } else { totalDistributedIn[_currentHalfYear] = oldDist.sub(subtracted); } return subtracted; } function _vouchersToWei(uint256 _value) internal view returns (uint256) { return _value.mul(Rs2c.RATE_COEFFICIENT2.div(vs2c.voucherMthEthRate; } function _weiToVouchers(uint256 _value) internal view returns (uint256) { return _value.mul(vs2c.voucherMthEthRate.div(Rs2c.RATE_COEFFICIENT2; } function _mthToVouchers(uint256 _value) internal view returns (uint256) { return _value.mul(vs2c.voucherMthRate.div(Rs2c.RATE_COEFFICIENT; } function _weiToMth(uint256 _value) internal view returns (uint256) { return _value.mul(ms2c.mthEthRate.div(Rs2c.RATE_COEFFICIENT; } function _totalVouchersSupply() internal view returns (uint256) { return _mthToVouchers(mthToken.balanceOf(address(this))); } function _vouchersInSharedPool(uint16 _currentHalfYear) internal view returns (uint256) { return _totalVouchersSupply().sub(_vouchersDistributed(_currentHalfYear)).sub(ts2c.totalPurchased; } function _vouchersDistributed(uint16 _currentHalfYear) internal view returns (uint256) { uint256 dist = totalDistributedIn[_currentHalfYear]; if (_currentHalfYear > 0) { dist = dist.add(totalDistributedIn[_currentHalfYear - 1]); } return dist; } function _distributedTo(address _owner, uint16 _currentHalfYear) internal view returns (uint256) { uint256 Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2 = distributed[_currentHalfYear][_owner]; if (_currentHalfYear > 0) { Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2 = Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2.add(distributed[_currentHalfYear - 1][_owner]); } return Ox80ba5c013d4e4c228a820c58a04ff5a16f1ba3a2; } function _currentHalfYear() internal view returns (uint16) { return uint16(now / Hs2c.HALF_YEAR_IN_SECONDS_AVG; }}struct scalar2Vector {uint256 totalPurchased;uint256 voucherMthEthRate;uint256 mthEthRate;uint256 voucherMthRate;uint256 RATE_COEFFICIENT2;uint256 RATE_COEFFICIENT;uint256 HALF_YEAR_IN_SECONDS_AVG;uint256 YEAR_IN_SECONDS_AVG;uint256 LEAP_YEAR_IN_SECONDS;uint256 YEAR_IN_SECONDS;uint256 DAY_IN_SECONDS;uint8 decimals;string Oxb4cb4e5db0ca4b9357b2721c554d7b26fed748bc;string Ox7bb6f488a7221be5c96c097fea8e35c6271b3db6;string standard;bool paused;address Ox263b1e6463cdd3db3c2e8c30ee54a5e83b54136e;}scalar2Vector s2c = scalar2Vector(0, 0, 0, 0, RATE_COEFFICIENT * RATE_COEFFICIENT, 1000000000000000000, YEAR_IN_SECONDS_AVG / 2, (YEAR_IN_SECONDS * 3 + LEAP_YEAR_IN_SECONDS) / 4, 366 * DAY_IN_SECONDS, 365 * DAY_IN_SECONDS, 86400, 5, "MTHV", "Monetha Voucher", "ERC20", false, address(0));