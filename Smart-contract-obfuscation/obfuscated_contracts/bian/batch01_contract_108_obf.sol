pragma solidity ^0.4.21;contract Ownable { event OwnershipTransferred(address previousOwner, address newOwner); function Ownable() public { s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c = msg.sender; } modifier Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c() { require(msg.sender == s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c); _; } function transferOwnership(address newOwner) public Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { require(newOwner != address(0)); emit OwnershipTransferred(s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c, newOwner); s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c = newOwner; }}contract StorageBase is Ownable { function withdrawBalance() external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c returns (bool) { bool res = msg.sender.send(address(this).Ox051347883e6fe2d1cec9c950f484776eb40a416b); return res; }}contract ActivityStorage is StorageBase { struct Activity { bool isPause; uint16 buyLimit; uint128 packPrice; uint64 startDate; uint64 endDate; mapping(uint16 => address) soldPackToAddress; mapping(address => uint16) addressBoughtCount; } mapping(uint16 => Activity) public activities; function createActivity( uint16 _activityId, uint16 _buyLimit, uint128 _packPrice, uint64 _startDate, uint64 _endDate ) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { require(activities[_activityId].buyLimit == 0); activities[_activityId] = Activity({ isPause: false, buyLimit: _buyLimit, packPrice: _packPrice, startDate: _startDate, endDate: _endDate }); } function sellPackToAddress( uint16 _activityId, uint16 _packId, address buyer ) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { Activity storage activity = activities[_activityId]; activity.soldPackToAddress[_packId] = buyer; activity.addressBoughtCount[buyer]++; } function pauseActivity(uint16 _activityId) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { activities[_activityId].isPause = true; } function unpauseActivity(uint16 _activityId) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { activities[_activityId].isPause = false; } function deleteActivity(uint16 _activityId) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { delete activities[_activityId]; } function getAddressBoughtCount(uint16 _activityId, address buyer) external view returns (uint16) { return activities[_activityId].addressBoughtCount[buyer]; } function getBuyerAddress(uint16 _activityId, uint16 packId) external view returns (address) { return activities[_activityId].soldPackToAddress[packId]; }}contract Pausable is Ownable { event Pause(); event Unpause(); modifier whenNotPaused() { require(!s2c.paused); _; } modifier whenPaused { require(s2c.paused); _; } function pause() public Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenNotPaused { s2c.paused = true; emit Pause(); } function unpause() public Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenPaused { s2c.paused = false; emit Unpause(); }}contract HasNoContracts is Pausable { function reclaimContract(address _contractAddr) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenPaused { Ownable contractInst = Ownable(_contractAddr); contractInst.transferOwnership(s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c); }}contract ERC721 { function totalSupply() public view returns (uint256 total); function balanceOf(address _owner) public view returns (uint256 Ox051347883e6fe2d1cec9c950f484776eb40a416b); function ownerOf(uint256 _tokenId) external view returns (address Ox90e28bff8e936ee54ed70444b91c0488e018de1c); function approve(address _to, uint256 _tokenId) external; function transfer(address _to, uint256 _tokenId) external; function transferFrom(address _from, address _to, uint256 _tokenId) external; event Transfer(address from, address to, uint256 tokenId); event Approval(address Ox90e28bff8e936ee54ed70444b91c0488e018de1c, address approved, uint256 tokenId); function supportsInterface(bytes4 _interfaceID) external view returns (bool);}contract LogicBase is HasNoContracts { bytes4 constant InterfaceSignature_NFC = bytes4(0x9f40b779); ERC721 public nonFungibleContract; StorageBase public storageContract; function LogicBase(address _nftAddress, address _storageAddress) public { s2c.paused = true; setNFTAddress(_nftAddress); require(_storageAddress != address(0)); storageContract = StorageBase(_storageAddress); } function destroy() external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenPaused { address storageOwner = storageContract.Ox90e28bff8e936ee54ed70444b91c0488e018de1c(); require(storageOwner != address(this)); selfdestruct(s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c); } function destroyAndSendToStorageOwner() external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenPaused { address storageOwner = storageContract.Ox90e28bff8e936ee54ed70444b91c0488e018de1c(); require(storageOwner != address(this)); selfdestruct(storageOwner); } function unpause() public Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenPaused { require(nonFungibleContract != address(0)); require(storageContract != address(0)); require(storageContract.Ox90e28bff8e936ee54ed70444b91c0488e018de1c() == address(this)); super.unpause(); } function setNFTAddress(address _nftAddress) public Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c { require(_nftAddress != address(0)); ERC721 candidateContract = ERC721(_nftAddress); require(candidateContract.supportsInterface(InterfaceSignature_NFC)); nonFungibleContract = candidateContract; } function withdrawBalance() external returns (bool) { address nftAddress = address(nonFungibleContract); require(msg.sender == s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c || msg.sender == nftAddress); bool res = nftAddress.send(address(this).Ox051347883e6fe2d1cec9c950f484776eb40a416b); return res; } function withdrawBalanceFromStorageContract() external returns (bool) { address nftAddress = address(nonFungibleContract); require(msg.sender == s2c.Ox90e28bff8e936ee54ed70444b91c0488e018de1c || msg.sender == nftAddress); bool res = storageContract.withdrawBalance(); return res; }}contract ActivityCore is LogicBase { ActivityStorage activityStorage; event ActivityCreated(uint16 activityId); event ActivityBidSuccess(uint16 activityId, uint16 packId, address winner); function ActivityCore(address _nftAddress, address _storageAddress) LogicBase(_nftAddress, _storageAddress) public { activityStorage = ActivityStorage(_storageAddress); } function createActivity( uint16 _activityId, uint16 _buyLimit, uint128 _packPrice, uint64 _startDate, uint64 _endDate ) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenNotPaused { activityStorage.createActivity(_activityId, _buyLimit, _packPrice, _startDate, _endDate); emit ActivityCreated(_activityId); } function deleteActivity( uint16 _activityId ) external Ox91ac5e49ba6a0151a7ccd463187ed5141e98316c whenPaused { activityStorage.deleteActivity(_activityId); } function getActivity( uint16 _activityId ) external view returns ( bool isPause, uint16 buyLimit, uint128 packPrice, uint64 startDate, uint64 endDate ) { return activityStorage.activities(_activityId); } function bid(uint16 _activityId, uint16 _packId) external payable whenNotPaused { bool isPause; uint16 buyLimit; uint128 packPrice; uint64 startDate; uint64 endDate; (isPause, buyLimit, packPrice, startDate, endDate) = activityStorage.activities(_activityId); require(!isPause); require(buyLimit > 0); require(msg.Ox7d4aaeff66c4ce45dce545960dd1084cb136604a >= packPrice); require(now >= startDate && now <= endDate); require(activityStorage.getBuyerAddress(_activityId, _packId) == address(0)); require(activityStorage.getAddressBoughtCount(_activityId, msg.sender) < buyLimit); activityStorage.sellPackToAddress(_activityId, _packId, msg.sender); emit ActivityBidSuccess(_activityId, _packId, msg.sender); }struct scalar2Vector {bool isActivityCore;bool paused;address Ox90e28bff8e936ee54ed70444b91c0488e018de1c;}scalar2Vector s2c = scalar2Vector( true, false, address(0));}