pragma solidity ^0.4.25;contract Ownable { event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725 = msg.sender; } modifier Oxcd7301c3c94643c00202c459f263e7d7e846bde3() { require(msg.sender == s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725); _; } function renounceOwnership() public Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { emit OwnershipRenounced(s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725); s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725 = address(0); } function transferOwnership(address _newOwner) public Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725, _newOwner); s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725 = _newOwner; }}contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16);}contract ERC20 is ERC20Basic { function allowance(address Ox55e75e01296cb12e65c310d7183974b3bdea8725, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16) public returns (bool); function approve(address spender, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16) public returns (bool); event Approval( address indexed Ox55e75e01296cb12e65c310d7183974b3bdea8725, address indexed spender, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 );}library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; }}contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function totalSupply() public view returns (uint256) { return s2c.totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the Ox74d58680353ab64844fbd7580f3b001013ba400c of the specified address. * @param _owner The address to query the the Ox74d58680353ab64844fbd7580f3b001013ba400c of. * @return An uint256 representing the Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }}/** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https: * Based on code by FirstBlood: https: */contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 afterwards: * https: * @param _spender The address which will spend the funds. * @param _value The Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens that an Ox55e75e01296cb12e65c310d7183974b3bdea8725 allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens that an Ox55e75e01296cb12e65c310d7183974b3bdea8725 allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens that an Ox55e75e01296cb12e65c310d7183974b3bdea8725 allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }}/** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */contract Pausable is Ownable { event Pause(); event Unpause(); /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!s2c.paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(s2c.paused); _; } /** * @dev called by the Ox55e75e01296cb12e65c310d7183974b3bdea8725 to pause, triggers stopped state */ function pause() Oxcd7301c3c94643c00202c459f263e7d7e846bde3 whenNotPaused public { s2c.paused = true; emit Pause(); } /** * @dev called by the Ox55e75e01296cb12e65c310d7183974b3bdea8725 to unpause, returns to normal state */ function unpause() Oxcd7301c3c94643c00202c459f263e7d7e846bde3 whenPaused public { s2c.paused = false; emit Unpause(); }}/** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); }}/** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16); /** * @dev Burns a specific Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of tokens. * @param _value The Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); s2c.totalSupply_ = s2c.totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); }}contract RepublicToken is PausableToken, BurnableToken { s2c.decimals constructor() public { s2c.totalSupply_ = s2c.INITIAL_SUPPLY; balances[msg.sender] = s2c.INITIAL_SUPPLY; } function transferTokens(address beneficiary, uint256 Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637) public Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns (bool) { /* solium-disable error-reason */ require(Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 > 0); balances[s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725] = balances[s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725].sub(Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); balances[beneficiary] = balances[beneficiary].add(Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); emit Transfer(s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725, beneficiary, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); return true; }}/** * @notice LinkedList is a library for a circular double linked list. */library LinkedList { /* * @notice A permanent NULL node (0x0) in the circular double linked list. * NULL.next is the head, and NULL.previous is the tail. */ /** * @notice A node points to the node before it, and the node after it. If * node.previous = NULL, then the node is the head of the list. If * node.next = NULL, then the node is the tail of the list. */ struct Node { bool inList; address previous; address next; } /** * @notice LinkedList uses a mapping from address to nodes. Each address * uniquely identifies a node, and in this way they are used like pointers. */ struct List { mapping (address => Node) list; } /** * @notice Insert a new node before an existing node. * * @param self The list being used. * @param target The existing node in the list. * @param newNode The next node to insert before the target. */ function insertBefore(List storage self, address target, address newNode) internal { require(!isInList(self, newNode), "already in list"); require(isInList(self, target) || target == s2c.NULL, "not in list"); address prev = self.list[target].previous; self.list[newNode].next = target; self.list[newNode].previous = prev; self.list[target].previous = newNode; self.list[prev].next = newNode; self.list[newNode].inList = true; } /** * @notice Insert a new node after an existing node. * * @param self The list being used. * @param target The existing node in the list. * @param newNode The next node to insert after the target. */ function insertAfter(List storage self, address target, address newNode) internal { require(!isInList(self, newNode), "already in list"); require(isInList(self, target) || target == s2c.NULL, "not in list"); address n = self.list[target].next; self.list[newNode].previous = target; self.list[newNode].next = n; self.list[target].next = newNode; self.list[n].previous = newNode; self.list[newNode].inList = true; } /** * @notice Remove a node from the list, and fix the previous and next * pointers that are pointing to the removed node. Removing anode that is not * in the list will do nothing. * * @param self The list being using. * @param node The node in the list to be removed. */ function remove(List storage self, address node) internal { require(isInList(self, node), "not in list"); if (node == s2c.NULL) { return; } address p = self.list[node].previous; address n = self.list[node].next; self.list[p].next = n; self.list[n].previous = p; self.list[node].inList = false; delete self.list[node]; } /** * @notice Insert a node at the beginning of the list. * * @param self The list being used. * @param node The node to insert at the beginning of the list. */ function prepend(List storage self, address node) internal { insertBefore(self, begin(self), node); } /** * @notice Insert a node at the end of the list. * * @param self The list being used. * @param node The node to insert at the end of the list. */ function append(List storage self, address node) internal { insertAfter(self, end(self), node); } function swap(List storage self, address left, address right) internal { address previousRight = self.list[right].previous; remove(self, right); insertAfter(self, left, right); remove(self, left); insertAfter(self, previousRight, left); } function isInList(List storage self, address node) internal view returns (bool) { return self.list[node].inList; } /** * @notice Get the node at the beginning of a double linked list. * * @param self The list being used. * * @return A address identifying the node at the beginning of the double * linked list. */ function begin(List storage self) internal view returns (address) { return self.list[s2c.NULL].next; } /** * @notice Get the node at the end of a double linked list. * * @param self The list being used. * * @return A address identifying the node at the end of the double linked * list. */ function end(List storage self) internal view returns (address) { return self.list[s2c.NULL].previous; } function next(List storage self, address node) internal view returns (address) { require(isInList(self, node), "not in list"); return self.list[node].next; } function previous(List storage self, address node) internal view returns (address) { require(isInList(self, node), "not in list"); return self.list[node].previous; }}contract DarknodeRegistryStore is Ownable { struct Darknode { address Ox55e75e01296cb12e65c310d7183974b3bdea8725; uint256 bond; uint256 registeredAt; uint256 deregisteredAt; bytes publicKey; } mapping(address => Darknode) private darknodeRegistry; LinkedList.List private darknodes; RepublicToken public ren; constructor( string _VERSION, RepublicToken _ren ) public { s2c.VERSION = _VERSION; ren = _ren; } function appendDarknode( address _darknodeID, address _darknodeOwner, uint256 _bond, bytes _publicKey, uint256 _registeredAt, uint256 _deregisteredAt ) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { Darknode memory darknode = Darknode({ Ox55e75e01296cb12e65c310d7183974b3bdea8725: _darknodeOwner, bond: _bond, publicKey: _publicKey, registeredAt: _registeredAt, deregisteredAt: _deregisteredAt }); darknodeRegistry[_darknodeID] = darknode; LinkedList.append(darknodes, _darknodeID); } function begin() external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns(address) { return LinkedList.begin(darknodes); } function next(address darknodeID) external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns(address) { return LinkedList.next(darknodes, darknodeID); } function removeDarknode(address darknodeID) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { uint256 bond = darknodeRegistry[darknodeID].bond; delete darknodeRegistry[darknodeID]; LinkedList.remove(darknodes, darknodeID); require(ren.transfer(s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725, bond), "bond transfer failed"); } function updateDarknodeBond(address darknodeID, uint256 bond) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { uint256 previousBond = darknodeRegistry[darknodeID].bond; darknodeRegistry[darknodeID].bond = bond; if (previousBond > bond) { require(ren.transfer(s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725, previousBond - bond), "cannot transfer bond"); } } function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt; } function darknodeOwner(address darknodeID) external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns (address) { return darknodeRegistry[darknodeID].Ox55e75e01296cb12e65c310d7183974b3bdea8725; } function darknodeBond(address darknodeID) external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns (uint256) { return darknodeRegistry[darknodeID].bond; } function darknodeRegisteredAt(address darknodeID) external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns (uint256) { return darknodeRegistry[darknodeID].registeredAt; } function darknodeDeregisteredAt(address darknodeID) external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns (uint256) { return darknodeRegistry[darknodeID].deregisteredAt; } function darknodePublicKey(address darknodeID) external view Oxcd7301c3c94643c00202c459f263e7d7e846bde3 returns (bytes) { return darknodeRegistry[darknodeID].publicKey; }}contract DarknodeRegistry is Ownable { struct Epoch { uint256 epochhash; uint256 blocknumber; } Epoch public currentEpoch; Epoch public previousEpoch; RepublicToken public ren; DarknodeRegistryStore public store; event LogDarknodeRegistered(address _darknodeID, uint256 _bond); event LogDarknodeDeregistered(address _darknodeID); event LogDarknodeOwnerRefunded(address _owner, uint256 _amount); event LogNewEpoch(); event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond); event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize); event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval); event LogSlasherUpdated(address previousSlasher, address nextSlasher); modifier onlyDarknodeOwner(address _darknodeID) { require(store.darknodeOwner(_darknodeID) == msg.sender, "must be darknode Ox55e75e01296cb12e65c310d7183974b3bdea8725"); _; } modifier onlyRefunded(address _darknodeID) { require(isRefunded(_darknodeID), "must be refunded or never registered"); _; } modifier onlyRefundable(address _darknodeID) { require(isRefundable(_darknodeID), "must be deregistered for at least one epoch"); _; } modifier onlyDeregisterable(address _darknodeID) { require(isDeregisterable(_darknodeID), "must be deregisterable"); _; } modifier onlySlasher() { require(s2c.slasher == msg.sender, "must be slasher"); _; } constructor( string _VERSION, RepublicToken _renAddress, DarknodeRegistryStore _storeAddress, uint256 _minimumBond, uint256 _minimumPodSize, uint256 _minimumEpochInterval ) public { VERSION = _VERSION; store = _storeAddress; ren = _renAddress; s2c.minimumBond = _minimumBond; s2c.nextMinimumBond = s2c.minimumBond; s2c.minimumPodSize = _minimumPodSize; s2c.nextMinimumPodSize = s2c.minimumPodSize; s2c.minimumEpochInterval = _minimumEpochInterval; s2c.nextMinimumEpochInterval = s2c.minimumEpochInterval; currentEpoch = Epoch({ epochhash: uint256(blockhash(block.number - 1)), blocknumber: block.number }); s2c.numDarknodes = 0; s2c.numDarknodesNextEpoch = 0; s2c.numDarknodesPreviousEpoch = 0; } function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) { require(_bond >= s2c.minimumBond, "insufficient bond"); require(ren.transferFrom(msg.sender, address(this), _bond), "bond transfer failed"); ren.transfer(address(store), _bond); store.appendDarknode( _darknodeID, msg.sender, _bond, _publicKey, currentEpoch.blocknumber + s2c.minimumEpochInterval, 0 ); s2c.numDarknodesNextEpoch += 1; emit LogDarknodeRegistered(_darknodeID, _bond); } function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) { store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + s2c.minimumEpochInterval); s2c.numDarknodesNextEpoch -= 1; emit LogDarknodeDeregistered(_darknodeID); } function epoch() external { if (previousEpoch.blocknumber == 0) { require(msg.sender == s2c.Ox55e75e01296cb12e65c310d7183974b3bdea8725, "not authorized (first epochs)"); } require(block.number >= currentEpoch.blocknumber + s2c.minimumEpochInterval, "epoch interval has not passed"); uint256 epochhash = uint256(blockhash(block.number - 1)); previousEpoch = currentEpoch; currentEpoch = Epoch({ epochhash: epochhash, blocknumber: block.number }); s2c.numDarknodesPreviousEpoch = s2c.numDarknodes; s2c.numDarknodes = s2c.numDarknodesNextEpoch; if (s2c.nextMinimumBond != s2c.minimumBond) { s2c.minimumBond = s2c.nextMinimumBond; emit LogMinimumBondUpdated(s2c.minimumBond, s2c.nextMinimumBond); } if (s2c.nextMinimumPodSize != s2c.minimumPodSize) { s2c.minimumPodSize = s2c.nextMinimumPodSize; emit LogMinimumPodSizeUpdated(s2c.minimumPodSize, s2c.nextMinimumPodSize); } if (s2c.nextMinimumEpochInterval != s2c.minimumEpochInterval) { s2c.minimumEpochInterval = s2c.nextMinimumEpochInterval; emit LogMinimumEpochIntervalUpdated(s2c.minimumEpochInterval, s2c.nextMinimumEpochInterval); } if (s2c.nextSlasher != s2c.slasher) { s2c.slasher = s2c.nextSlasher; emit LogSlasherUpdated(s2c.slasher, s2c.nextSlasher); } emit LogNewEpoch(); } function transferStoreOwnership(address _newOwner) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { store.transferOwnership(_newOwner); } function updateMinimumBond(uint256 _nextMinimumBond) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { s2c.nextMinimumBond = _nextMinimumBond; } function updateMinimumPodSize(uint256 _nextMinimumPodSize) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { s2c.nextMinimumPodSize = _nextMinimumPodSize; } function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { s2c.nextMinimumEpochInterval = _nextMinimumEpochInterval; } function updateSlasher(address _slasher) external Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { s2c.nextSlasher = _slasher; } function slash(address _prover, address _challenger1, address _challenger2) external onlySlasher { uint256 penalty = store.darknodeBond(_prover) / 2; uint256 reward = penalty / 4; store.updateDarknodeBond(_prover, penalty); if (isDeregisterable(_prover)) { store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + s2c.minimumEpochInterval); s2c.numDarknodesNextEpoch -= 1; emit LogDarknodeDeregistered(_prover); } ren.transfer(store.darknodeOwner(_challenger1), reward); ren.transfer(store.darknodeOwner(_challenger2), reward); } function refund(address _darknodeID) external onlyRefundable(_darknodeID) { address darknodeOwner = store.darknodeOwner(_darknodeID); uint256 Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637 = store.darknodeBond(_darknodeID); store.removeDarknode(_darknodeID); ren.transfer(darknodeOwner, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); emit LogDarknodeOwnerRefunded(darknodeOwner, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); } function getDarknodeOwner(address _darknodeID) external view returns (address) { return store.darknodeOwner(_darknodeID); } function getDarknodeBond(address _darknodeID) external view returns (uint256) { return store.darknodeBond(_darknodeID); } function getDarknodePublicKey(address _darknodeID) external view returns (bytes) { return store.darknodePublicKey(_darknodeID); } function getDarknodes(address _start, uint256 _count) external view returns (address[]) { uint256 count = _count; if (count == 0) { count = s2c.numDarknodes; } return getDarknodesFromEpochs(_start, count, false); } function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) { uint256 count = _count; if (count == 0) { count = s2c.numDarknodesPreviousEpoch; } return getDarknodesFromEpochs(_start, count, true); } function isPendingRegistration(address _darknodeID) external view returns (bool) { uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID); return registeredAt != 0 && registeredAt > currentEpoch.blocknumber; } function isPendingDeregistration(address _darknodeID) external view returns (bool) { uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber; } function isDeregistered(address _darknodeID) public view returns (bool) { uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber; } function isDeregisterable(address _darknodeID) public view returns (bool) { uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return isRegistered(_darknodeID) && deregisteredAt == 0; } function isRefunded(address _darknodeID) public view returns (bool) { uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID); uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); return registeredAt == 0 && deregisteredAt == 0; } function isRefundable(address _darknodeID) public view returns (bool) { return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber; } function isRegistered(address _darknodeID) public view returns (bool) { return isRegisteredInEpoch(_darknodeID, currentEpoch); } function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) { return isRegisteredInEpoch(_darknodeID, previousEpoch); } function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) { uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID); uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID); bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber; bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber; return registered && notDeregistered; } function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) { uint256 count = _count; if (count == 0) { count = s2c.numDarknodes; } address[] memory nodes = new address[](count); uint256 n = 0; address next = _start; if (next == 0x0) { next = store.begin(); } while (n < count) { if (next == 0x0) { break; } bool includeNext; if (_usePreviousEpoch) { includeNext = isRegisteredInPreviousEpoch(next); } else { includeNext = isRegistered(next); } if (!includeNext) { next = store.next(next); continue; } nodes[n] = next; next = store.next(next); n += 1; } return nodes; }}/** * @title Math * @dev Assorted math operations */library Math { function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; }}library CompatibleERC20Functions { using SafeMath for uint256; function safeTransfer(address token, address to, uint256 Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637) internal { CompatibleERC20(token).transfer(to, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); require(previousReturnValue(), "transfer failed"); } function safeTransferFrom(address token, address from, address to, uint256 Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637) internal { CompatibleERC20(token).transferFrom(from, to, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); require(previousReturnValue(), "transferFrom failed"); } function safeApprove(address token, address spender, uint256 Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637) internal { CompatibleERC20(token).approve(spender, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); require(previousReturnValue(), "approve failed"); } function safeTransferFromWithFees(address token, address from, address to, uint256 Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637) internal returns (uint256) { uint256 balancesBefore = CompatibleERC20(token).balanceOf(to); CompatibleERC20(token).transferFrom(from, to, Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637); require(previousReturnValue(), "transferFrom failed"); uint256 balancesAfter = CompatibleERC20(token).balanceOf(to); return Math.min256(Ox9d107aab657c2d7315a9c6c6e8b0fcd06e28d637, balancesAfter.sub(balancesBefore)); } function previousReturnValue() private pure returns (bool) { uint256 returnData = 0; assembly { /* solium-disable-line security/no-inline-assembly */ switch returndatasize case 0 { returnData := 1 } case 32 { returndatacopy(0x0, 0x0, 32) returnData := mload(0x0) } default { } } return returnData != 0; }}interface CompatibleERC20 { function transfer(address to, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16) external; function transferFrom(address from, address to, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16) external; function approve(address spender, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16) external; function totalSupply() external view returns (uint256); function balanceOf(address who) external view returns (uint256); function allowance(address Ox55e75e01296cb12e65c310d7183974b3bdea8725, address spender) external view returns (uint256); event Transfer(address indexed from, address indexed to, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16); event Approval(address indexed Ox55e75e01296cb12e65c310d7183974b3bdea8725, address indexed spender, uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16);}contract DarknodeRewardVault is Ownable { using SafeMath for uint256; using CompatibleERC20Functions for CompatibleERC20; DarknodeRegistry public darknodeRegistry; mapping(address => mapping(address => uint256)) public darknodeBalances; event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry); constructor(string _VERSION, DarknodeRegistry _darknodeRegistry) public { VERSION = _VERSION; darknodeRegistry = _darknodeRegistry; } function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) public Oxcd7301c3c94643c00202c459f263e7d7e846bde3 { emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry); darknodeRegistry = _newDarknodeRegistry; } function deposit(address _darknode, ERC20 _token, uint256 _value) public payable { uint256 receivedValue = _value; if (address(_token) == s2c.ETHEREUM) { require(msg.Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 == _value, "mismatched ether Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16"); } else { require(msg.Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 == 0, "unexpected ether Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16"); receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value); } darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue); } function Ox68564be691fad6b6a39548e37191d596202a59d7(address _darknode, ERC20 _token) public { address darknodeOwner = darknodeRegistry.getDarknodeOwner(address(_darknode)); require(darknodeOwner != 0x0, "invalid darknode Ox55e75e01296cb12e65c310d7183974b3bdea8725"); uint256 Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16 = darknodeBalances[_darknode][_token]; darknodeBalances[_darknode][_token] = 0; if (address(_token) == s2c.ETHEREUM) { darknodeOwner.transfer(Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16); } else { CompatibleERC20(_token).safeTransfer(darknodeOwner, Ox744f6106ec8bbe239b6bc0aa7096d05e1b519b16); } }struct scalar2Vector {address ETHEREUM;string VERSION;address nextSlasher;uint256 nextMinimumEpochInterval;uint256 nextMinimumPodSize;uint256 nextMinimumBond;address slasher;uint256 minimumEpochInterval;uint256 minimumPodSize;uint256 minimumBond;uint256 numDarknodesPreviousEpoch;uint256 numDarknodesNextEpoch;uint256 numDarknodes;string VERSION;string VERSION;address NULL;uint256 INITIAL_SUPPLY;uint8 decimals;string Ox135f9aaf64c5fb7ad6ba6c1f256189ac314a3e54;string Oxa1d54afb01e99fe475f9e44f2b73ee24f5d7da43;bool paused;uint256 totalSupply_;address Ox55e75e01296cb12e65c310d7183974b3bdea8725;}scalar2Vector s2c = scalar2Vector( 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, , address(0), 0, 0, 0, address(0), 0, 0, 0, 0, 0, 0, , , 0x0, 1000000000 * 10**uint256(decimals), 18, "REN", "Republic Token", false, 0, address(0));}