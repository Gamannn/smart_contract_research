pragma solidity ^0.4.12;contract SafeMath { function safeMul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function safeSub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; }}contract Ox0a933436207d80264fb0fc9b77602a376a13d629 { function balanceOf(address who) constant returns (uint256); function transfer(address Ox294a8eaae5683d1639eb4a40757830ba8cfa4310, uint256 value) returns (bool); event Transfer(address indexed Ox03428440bd42f7c95e2aa926240395329bf23528, address indexed Ox294a8eaae5683d1639eb4a40757830ba8cfa4310, uint256 value); function allowance(address Ox8fea314db04a6d89ad207851d699a99fe15dc802, address spender) constant returns (uint256); function Ox4e4c201580832f2475a69238f1b05930e0aa882c(address Ox03428440bd42f7c95e2aa926240395329bf23528, address Ox294a8eaae5683d1639eb4a40757830ba8cfa4310, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed Ox8fea314db04a6d89ad207851d699a99fe15dc802, address indexed spender, uint256 value);}contract StandardToken is Ox0a933436207d80264fb0fc9b77602a376a13d629, SafeMath { event Minted(address receiver, uint Ox8f90649d071fc56ab8229e51948c1834612c7990); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length != size + 4) { throw; } _; } function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool Ox570fd05a22fbe87fb1d7e84503d4b44cc138b6e1) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function Ox4e4c201580832f2475a69238f1b05930e0aa882c(address _from, address _to, uint _value) returns (bool Ox570fd05a22fbe87fb1d7e84503d4b44cc138b6e1) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool Ox570fd05a22fbe87fb1d7e84503d4b44cc138b6e1) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } function addApproval(address _spender, uint _addedValue) onlyPayloadSize(2 * 32) returns (bool Ox570fd05a22fbe87fb1d7e84503d4b44cc138b6e1) { uint oldValue = allowed[msg.sender][_spender]; allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function subApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2 * 32) returns (bool Ox570fd05a22fbe87fb1d7e84503d4b44cc138b6e1) { uint oldVal = allowed[msg.sender][_spender]; if (_subtractedValue > oldVal) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }}contract BurnableToken is StandardToken { event Burned(address burner, uint burnedAmount); function burn(uint burnAmount) { address burner = msg.sender; balances[burner] = safeSub(balances[burner], burnAmount); s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7 = safeSub(s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7, burnAmount); Burned(burner, burnAmount); }}contract UpgradeAgent { function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public;}contract UpgradeableToken is StandardToken { /** The next contract where the Oxc7ee341d875fcddd87a3342c682b991c662a4e44 will be migrated. */ UpgradeAgent public upgradeAgent; /** How many Oxc7ee341d875fcddd87a3342c682b991c662a4e44 we have upgraded by now. */ /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their Oxc7ee341d875fcddd87a3342c682b991c662a4e44 * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his Oxc7ee341d875fcddd87a3342c682b991c662a4e44. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { s2c.upgradeMaster = _upgradeMaster; } /** * Allow the token holder Ox294a8eaae5683d1639eb4a40757830ba8cfa4310 upgrade some of their Oxc7ee341d875fcddd87a3342c682b991c662a4e44 Ox294a8eaae5683d1639eb4a40757830ba8cfa4310 a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { throw; } if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7 = safeSub(s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7, value); s2c.totalUpgraded = safeAdd(s2c.totalUpgraded, value); upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { throw; } if (agent == 0x0) throw; if (msg.sender != s2c.upgradeMaster) throw; if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); if(!upgradeAgent.isUpgradeAgent()) throw; if (upgradeAgent.originalSupply() != s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(s2c.totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us Ox294a8eaae5683d1639eb4a40757830ba8cfa4310 set a new Ox8fea314db04a6d89ad207851d699a99fe15dc802 for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != s2c.upgradeMaster) throw; s2c.upgradeMaster = master; } /** * Child contract can enable Ox294a8eaae5683d1639eb4a40757830ba8cfa4310 provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; }}contract Lescoin is BurnableToken, UpgradeableToken { string public name; string public symbol; function Lescoin(address _owner, address _init) UpgradeableToken(_owner) { name = "Lescoin"; symbol = "LSC"; s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7 = 200000000000000; s2c.decimals = 8; balances[_init] = s2c.Oxd921afe7271ea1113f246301de66e41b2e04d0d7; }}contract LescoinPreSale { Lescoin public tokenReward; function LescoinPreSale( address _beneficiary, address _coldWallet, uint _ethPrice, uint _bonus, Lescoin _addressOfToken ) { s2c.beneficiary = _beneficiary; s2c.coldWallet = _coldWallet; s2c.ethPrice = _ethPrice; s2c.bonus = _bonus; tokenReward = Lescoin(_addressOfToken); } function () payable { uint Ox8f90649d071fc56ab8229e51948c1834612c7990 = msg.value; uint tokenAmount = Ox8f90649d071fc56ab8229e51948c1834612c7990 * s2c.ethPrice / s2c.Ox6116e94dbcff4e194099ff7e5c49bbbe07525982 / 1000000000000; if (tokenAmount < s2c.minSaleAmount) throw; s2c.amountRaised += Ox8f90649d071fc56ab8229e51948c1834612c7990; tokenReward.transfer(msg.sender, tokenAmount * (100 + s2c.bonus) / 100); } function WithdrawETH(uint _amount) { if (s2c.beneficiary != msg.sender) throw; s2c.coldWallet.transfer(_amount); } function WithdrawTokens(uint _amount) { if (s2c.beneficiary != msg.sender) throw; tokenReward.transfer(s2c.coldWallet, _amount); } function TransferTokens(address _to, uint _amount) { if (s2c.beneficiary != msg.sender) throw; tokenReward.transfer(_to, _amount); } function ChangeEthPrice(uint _ethPrice) { if (s2c.beneficiary != msg.sender) throw; s2c.ethPrice = _ethPrice; } function ChangeBonus(uint _bonus) { if (s2c.beneficiary != msg.sender) throw; s2c.bonus = _bonus; }struct scalar2Vector {uint256 minSaleAmount;uint256 Ox6116e94dbcff4e194099ff7e5c49bbbe07525982;uint256 amountRaised;uint256 bonus;uint256 ethPrice;address coldWallet;address beneficiary;uint256 decimals;uint256 totalUpgraded;address upgradeMaster;uint256 originalSupply;address BURN_ADDRESS;uint256 Oxd921afe7271ea1113f246301de66e41b2e04d0d7;}scalar2Vector s2c = scalar2Vector( 10000, 50, 0, 0, 0, address(0), address(0), 0, 0, address(0), 0, 0, 0);}