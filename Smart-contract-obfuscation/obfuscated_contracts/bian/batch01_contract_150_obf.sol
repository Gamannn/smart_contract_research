pragma solidity ^0.4.24;contract SHT_Token { modifier onlyTokenHolders() { require(myTokens() > 0); _; } modifier onlyDividendPositive() { require(myDividends() > 0); _; } modifier onlyOwner() { require (address(msg.sender) == s2c.owner); _; } modifier onlyFoundersIfNotPublic() { if(!s2c.openToThePublic) { require (founders[address(msg.sender)] == true); } _; } event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted ); event onTokenSell( address indexed customerAddress, uint256 tokensBurned, uint256 ethereumEarned ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event lotteryPayout( address customerAddress, uint256 lotterySupply ); event whaleDump( uint256 amount ); event Transfer( address indexed from, address indexed to, uint256 tokens ); Onigiri2 private ob2; mapping(address => uint256) internal publicTokenLedger; mapping(address => uint256) public whaleLedger; mapping(address => int256) internal payoutsTo_; mapping(address => bool) internal founders; address[] lotteryPlayers; constructor() public { s2c.owner = address(msg.sender); s2c.dev = address(0x7e474fe5Cfb720804860215f407111183cbc2f85); founders[0x013f3B8C9F1c4f2f28Fd9cc1E1CF3675Ae920c76] = true; founders[0xF57924672D6dBF0336c618fDa50E284E02715000] = true; founders[0xE4Cf94e5D30FB4406A2B139CD0e872a1C8012dEf] = true; ob2 = Onigiri2(0xb8a68f9B8363AF79dEf5c5e11B12e8A258cE5be8); } function buy() onlyFoundersIfNotPublic() public payable returns(uint256) { require (msg.sender == tx.origin); uint256 tokenAmount; tokenAmount = purchaseTokens(msg.value); return tokenAmount; } function() payable public { buy(); } function reinvest() onlyDividendPositive() public { require (msg.sender == tx.origin); uint256 dividends = myDividends(); address customerAddress = msg.sender; payoutsTo_[customerAddress] += int256(dividends * s2c.magnitude); uint256 _tokens = purchaseTokens(dividends); emit onReinvestment(customerAddress, dividends, _tokens); } function exit() onlyTokenHolders() public { require (msg.sender == tx.origin); address customerAddress = address(msg.sender); uint256 _tokens = publicTokenLedger[customerAddress]; if(_tokens > 0) { sell(_tokens); } Oxb967c8cbab5ca43ac376972090c6336d0117d312(); } function Oxb967c8cbab5ca43ac376972090c6336d0117d312() onlyDividendPositive() public { require (msg.sender == tx.origin); address customerAddress = msg.sender; uint256 dividends = myDividends(); payoutsTo_[customerAddress] += int256(dividends * s2c.magnitude); customerAddress.transfer(dividends); emit onWithdraw(customerAddress, dividends); } function sell(uint256 _amountOfTokens) onlyTokenHolders() public { require (msg.sender == tx.origin); require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0)); uint256 _tokens = _amountOfTokens; uint256 ethereum = tokensToEthereum_(_tokens); uint256 undividedDivs = SafeMath.div(ethereum, s2c.dividendFee); uint256 communityDivs = SafeMath.div(undividedDivs, 2); uint256 ob2Divs = SafeMath.div(undividedDivs, 4); uint256 lotteryDivs = SafeMath.div(undividedDivs, 10); uint256 tip4Dev = lotteryDivs; uint256 whaleDivs = SafeMath.sub(communityDivs, (ob2Divs + lotteryDivs)); uint256 dividends = SafeMath.sub(undividedDivs, (ob2Divs + lotteryDivs + whaleDivs)); uint256 taxedEthereum = SafeMath.sub(ethereum, (undividedDivs + tip4Dev)); whaleLedger[s2c.owner] += whaleDivs; s2c.lotterySupply += ethereumToTokens_(lotteryDivs); ob2.fromGame.value(ob2Divs)(); s2c.dev.transfer(tip4Dev); s2c.tokenSupply -= _tokens; publicTokenLedger[msg.sender] -= _tokens; int256 _updatedPayouts = (int256) (s2c.profitPerShare_ * _tokens + (taxedEthereum * s2c.magnitude)); payoutsTo_[msg.sender] -= _updatedPayouts; if (s2c.tokenSupply > 0) { s2c.profitPerShare_ += ((dividends * s2c.magnitude) / s2c.tokenSupply); } emit onTokenSell(msg.sender, _tokens, taxedEthereum); } function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders() public returns(bool) { assert(_toAddress != s2c.owner); require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 )); publicTokenLedger[msg.sender] -= _amountOfTokens; publicTokenLedger[_toAddress] += _amountOfTokens; payoutsTo_[msg.sender] -= int256(s2c.profitPerShare_ * _amountOfTokens); payoutsTo_[_toAddress] += int256(s2c.profitPerShare_ * _amountOfTokens); emit Transfer(msg.sender, _toAddress, _amountOfTokens); return true; } function goPublic() onlyOwner() public returns(bool) { s2c.openToThePublic = true; return s2c.openToThePublic; } /*---------- HELPERS AND CALCULATORS ----------*/ /** * Method to view the current Ethereum stored in the contract */ function totalEthereumBalance() public view returns(uint) { return address(this).balance; } /** * Retrieve the total token supply. */ function totalSupply() public view returns(uint256) { return (s2c.tokenSupply + s2c.lotterySupply); } /** * Retrieve the tokens owned by the caller. */ function myTokens() public view returns(uint256) { return balanceOf(msg.sender); } /** * Retrieve the balance of the whale. */ function whaleBalance() public view returns(uint256) { return whaleLedger[s2c.owner]; } /** * Retrieve the balance of the whale. */ function lotteryBalance() public view returns(uint256) { return s2c.lotterySupply; } /** * Retrieve the dividends owned by the caller. */ function myDividends() public view returns(uint256) { return dividendsOf(msg.sender); } /** * Retrieve the token balance of any single address. */ function balanceOf(address customerAddress) view public returns(uint256) { return publicTokenLedger[customerAddress]; } /** * Retrieve the dividend balance of any single address. */ function dividendsOf(address customerAddress) view public returns(uint256) { return (uint256) ((int256)(s2c.profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / s2c.magnitude; } /** * Return the buy and sell price of 1 individual token. */ function buyAndSellPrice() public pure returns(uint256) { uint256 ethereum = s2c.tokenPrice; uint256 dividends = SafeMath.div((ethereum * s2c.dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); return taxedEthereum; } /** * Function for the frontend to dynamically retrieve the price of buy orders. */ function calculateTokensReceived(uint256 ethereumToSpend) public pure returns(uint256) { require(ethereumToSpend >= s2c.tokenPrice); uint256 dividends = SafeMath.div((ethereumToSpend * s2c.dividendFee), 100); uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends); uint256 amountOfTokens = ethereumToTokens_(taxedEthereum); return amountOfTokens; } /** * Function for the frontend to dynamically retrieve the price of sell orders. */ function calculateEthereumReceived(uint256 tokensToSell) public view returns(uint256) { require(tokensToSell <= s2c.tokenSupply); uint256 ethereum = tokensToEthereum_(tokensToSell); uint256 dividends = SafeMath.div((ethereum * s2c.dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); return taxedEthereum; } /*========================================== = INTERNAL FUNCTIONS = ==========================================*/ function purchaseTokens(uint256 incomingEthereum) internal returns(uint256) { uint256 undividedDivs = SafeMath.div(incomingEthereum, s2c.dividendFee); uint256 communityDivs = SafeMath.div(undividedDivs, 2); uint256 ob2Divs = SafeMath.div(undividedDivs, 4); uint256 lotteryDivs = SafeMath.div(undividedDivs, 10); uint256 tip4Dev = lotteryDivs; uint256 whaleDivs = SafeMath.sub(communityDivs, (ob2Divs + lotteryDivs)); uint256 dividends = SafeMath.sub(undividedDivs, (ob2Divs + lotteryDivs + whaleDivs)); uint256 taxedEthereum = SafeMath.sub(incomingEthereum, (undividedDivs + tip4Dev)); uint256 amountOfTokens = ethereumToTokens_(taxedEthereum); whaleLedger[s2c.owner] += whaleDivs; s2c.lotterySupply += ethereumToTokens_(lotteryDivs); lotteryPlayers.push(msg.sender); ob2.fromGame.value(ob2Divs)(); s2c.dev.transfer(tip4Dev); uint256 fee = dividends * s2c.magnitude; require(amountOfTokens > 0 && (amountOfTokens + s2c.tokenSupply) > s2c.tokenSupply); uint256 payoutDividends = isWhalePaying(); if(s2c.tokenSupply > 0) { s2c.tokenSupply += amountOfTokens; s2c.profitPerShare_ += ((payoutDividends + dividends) * s2c.magnitude / (s2c.tokenSupply)); fee -= fee-(amountOfTokens * (dividends * s2c.magnitude / (s2c.tokenSupply))); } else { s2c.tokenSupply = amountOfTokens; if(whaleLedger[s2c.owner] == 0) { whaleLedger[s2c.owner] = payoutDividends; } } publicTokenLedger[msg.sender] += amountOfTokens; int256 _updatedPayouts = int256((s2c.profitPerShare_ * amountOfTokens) - fee); payoutsTo_[msg.sender] += _updatedPayouts; emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens); return amountOfTokens; } /** * Calculate token sell value. * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation. */ function isWhalePaying() private returns(uint256) { uint256 payoutDividends = 0; if(whaleLedger[s2c.owner] >= 1 ether) { if(lotteryPlayers.length > 0) { uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length; publicTokenLedger[lotteryPlayers[winner]] += s2c.lotterySupply; emit lotteryPayout(lotteryPlayers[winner], s2c.lotterySupply); s2c.tokenSupply += s2c.lotterySupply; s2c.lotterySupply = 0; delete lotteryPlayers; } payoutDividends = whaleLedger[s2c.owner]; whaleLedger[s2c.owner] = 0; emit whaleDump(payoutDividends); } return payoutDividends; } /** * Calculate Token price based on an amount of incoming ethereum *It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation. */ function ethereumToTokens_(uint256 ethereum) internal pure returns(uint256) { uint256 tokensReceived = ((ethereum / s2c.tokenPrice) * 1e18); return tokensReceived; } /** * Calculate token sell value. * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation. */ function tokensToEthereum_(uint256 coin) internal pure returns(uint256) { uint256 ethReceived = s2c.tokenPrice * (SafeMath.div(coin, 1e18)); return ethReceived; }}contract Onigiri2 { function fromGame() external payable;}/** * @title SafeMath * @dev Math operations with safety checks that throw on error */library SafeMath { /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; }struct scalar2Vector {uint256 profitPerShare_;uint256 tokenSupply;uint256 lotterySupply;uint256 magnitude;uint256 tokenPrice;uint8 ob2Fee;uint8 devFee;uint8 lotteryFee;uint8 dividendFee;uint8 decimals;address dev;address owner;bool openToThePublic;string symbol;string name;}scalar2Vector s2c = scalar2Vector(0, 0, 0, 2**64, 400000000000000, 2, 5, 5, 10, 18, address(0), address(0), false, "SHT", "SHT Token");}