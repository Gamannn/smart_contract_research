pragma solidity ^0.4.19;contract BaseToken { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }}contract ICOToken is BaseToken { event ICO(address indexed from, uint256 indexed value, uint256 tokenValue); event Withdraw(address indexed from, address indexed holder, uint256 value); function ico() public payable { require(now >= Ox0c59274f7e0706c658850d1c53fff04072962875.icoBegintime && now <= Ox0c59274f7e0706c658850d1c53fff04072962875.icoEndtime); uint256 tokenValue = (msg.value * Ox0c59274f7e0706c658850d1c53fff04072962875.icoRatio * 10 ** uint256(Ox0c59274f7e0706c658850d1c53fff04072962875.decimals)) / (1 ether / 1 wei); if (tokenValue == 0 || balanceOf[Ox0c59274f7e0706c658850d1c53fff04072962875.icoSender] < tokenValue) { revert(); } _transfer(Ox0c59274f7e0706c658850d1c53fff04072962875.icoSender, msg.sender, tokenValue); ICO(msg.sender, msg.value, tokenValue); } function withdraw() public { uint256 balance = this.balance; Ox0c59274f7e0706c658850d1c53fff04072962875.icoHolder.transfer(balance); Withdraw(msg.sender, Ox0c59274f7e0706c658850d1c53fff04072962875.icoHolder, balance); }}contract CustomToken is BaseToken, ICOToken { function CustomToken() public { Ox0c59274f7e0706c658850d1c53fff04072962875.totalSupply = 81000000000000000000000000; Ox0c59274f7e0706c658850d1c53fff04072962875.name = 'PublicKey'; Ox0c59274f7e0706c658850d1c53fff04072962875.symbol = 'PKC'; Ox0c59274f7e0706c658850d1c53fff04072962875.decimals = 18; balanceOf[0x58cbc34576efc4f2591fbc6258f89961e7e34d48] = Ox0c59274f7e0706c658850d1c53fff04072962875.totalSupply; Transfer(address(0), 0x58cbc34576efc4f2591fbc6258f89961e7e34d48, Ox0c59274f7e0706c658850d1c53fff04072962875.totalSupply); Ox0c59274f7e0706c658850d1c53fff04072962875.icoRatio = 11000; Ox0c59274f7e0706c658850d1c53fff04072962875.icoBegintime = 1527811200; Ox0c59274f7e0706c658850d1c53fff04072962875.icoEndtime = 1622559600; Ox0c59274f7e0706c658850d1c53fff04072962875.icoSender = 0x58cbc34576efc4f2591fbc6258f89961e7e34d48; Ox0c59274f7e0706c658850d1c53fff04072962875.icoHolder = 0x58cbc34576efc4f2591fbc6258f89961e7e34d48; } function() public payable { ico(); }struct scalar2Vector {address icoHolder;address icoSender;uint256 icoEndtime;uint256 icoBegintime;uint256 icoRatio;uint256 totalSupply;uint8 decimals;string symbol;string name;}scalar2Vector Ox0c59274f7e0706c658850d1c53fff04072962875 = scalar2Vector(address(0), address(0), 0, 0, 0, 0, 0, , );}