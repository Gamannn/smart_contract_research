pragma solidity ^0.4.24;contract _8thereum { modifier onlyTokenHolders() { require(myTokens() > 0); _; } modifier onlyDividendPositive() { require(myDividends(true) > 0); _; } modifier onlyOwner() { require (address(msg.sender) == Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner); _; } modifier onlyNonOwner() { require (address(msg.sender) != Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner); _; } modifier onlyFoundersIfNotPublic() { if(!Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.openToThePublic) { require (founders[address(msg.sender)] == true); } _; } modifier onlyApprovedContracts() { if(!gameList[msg.sender]) { require (msg.sender == tx.origin); } _; } event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address indexed referredBy ); event onTokenSell( address indexed customerAddress, uint256 tokensBurned, uint256 ethereumEarned ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event lotteryPayout( address customerAddress, uint256 lotterySupply ); event whaleDump( uint256 Ox42f5cf26da0dc6d08b7176918ba3ca584f6df6eb ); event Transfer( address indexed from, address indexed to, uint256 tokens ); mapping(address => bool) internal gameList; mapping(address => uint256) internal publicTokenLedger; mapping(address => uint256) public whaleLedger; mapping(address => uint256) public gameLedger; mapping(address => uint256) internal referralBalances; mapping(address => int256) internal payoutsTo_; mapping(address => mapping(address => uint256)) public gamePlayers; mapping(address => bool) internal founders; address[] lotteryPlayers; constructor() public { Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner = address(msg.sender); founders[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] = true; founders[0x7e474fe5Cfb720804860215f407111183cbc2f85] = true; founders[0x5138240E96360ad64010C27eB0c685A8b2eDE4F2] = true; founders[0xAA7A7C2DECB180f68F11E975e6D92B5Dc06083A6] = true; founders[0x6DC622a04Fd13B6a1C3C5B229CA642b8e50e1e74] = true; founders[0x41a21b264F9ebF6cF571D4543a5b3AB1c6bEd98C] = true; } function buy(address referredyBy) onlyFoundersIfNotPublic() public payable returns(uint256) { require (msg.sender == tx.origin); excludeWhale(referredyBy); } function() onlyFoundersIfNotPublic() payable public { require (msg.sender == tx.origin); excludeWhale(0x0); } function reinvest() onlyDividendPositive() onlyNonOwner() public { require (msg.sender == tx.origin); uint256 dividends = myDividends(false); address customerAddress = msg.sender; payoutsTo_[customerAddress] += int256(SafeMath.mul(dividends, Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude)); dividends += referralBalances[customerAddress]; referralBalances[customerAddress] = 0; uint256 _tokens = purchaseTokens(dividends, 0x0); emit onReinvestment(customerAddress, dividends, _tokens); } function exit() onlyNonOwner() onlyTokenHolders() public { require (msg.sender == tx.origin); address customerAddress = address(msg.sender); uint256 _tokens = publicTokenLedger[customerAddress]; if(_tokens > 0) { sell(_tokens); } withdraw(); } function withdraw() onlyNonOwner() onlyDividendPositive() public { require (msg.sender == tx.origin); address customerAddress = msg.sender; uint256 dividends = myDividends(false); payoutsTo_[customerAddress] += int256(SafeMath.mul(dividends, Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude)); dividends += referralBalances[customerAddress]; referralBalances[customerAddress] = 0; customerAddress.transfer(dividends); emit onWithdraw(customerAddress, dividends); } function sell(uint256 _amountOfTokens) onlyNonOwner() onlyTokenHolders() public { require (msg.sender == tx.origin); require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0)); uint256 _tokens = _amountOfTokens; uint256 ethereum = tokensToEthereum_(_tokens); uint256 dividends = (ethereum * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.dividendFee) / 100; uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); uint256 lotteryAndWhaleFee = dividends / 3; dividends -= lotteryAndWhaleFee; uint256 lotteryFee = lotteryAndWhaleFee / 2; uint256 whaleFee = lotteryAndWhaleFee - lotteryFee; whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] += whaleFee; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply += ethereumToTokens_(lotteryFee); Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply -= _tokens; publicTokenLedger[msg.sender] -= _tokens; int256 _updatedPayouts = (int256) (Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * _tokens + (taxedEthereum * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude)); payoutsTo_[msg.sender] -= _updatedPayouts; if (Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply > 0) { Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ = SafeMath.add(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_, (dividends * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude) / Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply); } emit onTokenSell(msg.sender, _tokens, taxedEthereum); } function transfer(address _toAddress, uint256 _amountOfTokens) onlyNonOwner() onlyTokenHolders() onlyApprovedContracts() public returns(bool) { assert(_toAddress != Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner); if(gameList[msg.sender] == true) { require((_amountOfTokens <= gameLedger[msg.sender]) && (_amountOfTokens > 0 )); gameLedger[msg.sender] -= _amountOfTokens; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.gameSuppply -= _amountOfTokens; publicTokenLedger[_toAddress] += _amountOfTokens; payoutsTo_[_toAddress] += int256(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * _amountOfTokens); } else if (gameList[_toAddress] == true) { require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 && (_amountOfTokens == 1e18))); publicTokenLedger[msg.sender] -= _amountOfTokens; gameLedger[_toAddress] += _amountOfTokens; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.gameSuppply += _amountOfTokens; gamePlayers[_toAddress][msg.sender] += _amountOfTokens; payoutsTo_[msg.sender] -= int256(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * _amountOfTokens); } else{ require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 )); publicTokenLedger[msg.sender] -= _amountOfTokens; publicTokenLedger[_toAddress] += _amountOfTokens; payoutsTo_[msg.sender] -= int256(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * _amountOfTokens); payoutsTo_[_toAddress] += int256(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * _amountOfTokens); } emit Transfer(msg.sender, _toAddress, _amountOfTokens); return true; } function setGames(address newGameAddress) onlyOwner() public { gameList[newGameAddress] = true; } /** * Want to prevent snipers from buying prior to launch */ function goPublic() onlyOwner() public returns(bool) { Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.openToThePublic = true; return Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.openToThePublic; } /*---------- HELPERS AND CALCULATORS ----------*/ /** * Method to view the current Ethereum stored in the contract */ function totalEthereumBalance() public view returns(uint) { return address(this).balance; } /** * Retrieve the total token supply. */ function totalSupply() public view returns(uint256) { return (Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply + Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply + Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.gameSuppply); } /** * Retrieve the tokens owned by the caller. */ function myTokens() public view returns(uint256) { return balanceOf(msg.sender); } /** * Retrieve the dividends owned by the caller. * If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations. * The reason for this, is that in the frontend, we will want to get the total divs (global + ref) * But in the internal calculations, we want them separate. */ function myDividends(bool _includeReferralBonus) public view returns(uint256) { return _includeReferralBonus ? dividendsOf(msg.sender) + referralBalances[msg.sender] : dividendsOf(msg.sender) ; } /** * Retrieve the token balance of any single address. */ function balanceOf(address customerAddress) view public returns(uint256) { uint256 balance; if (customerAddress == Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner) { balance = whaleLedger[customerAddress]; } else if(gameList[customerAddress] == true) { balance = gameLedger[customerAddress]; } else { balance = publicTokenLedger[customerAddress]; } return balance; } /** * Retrieve the dividend balance of any single address. */ function dividendsOf(address customerAddress) view public returns(uint256) { return (uint256) ((int256)(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude; } /** * Return the buy and sell price of 1 individual token. */ function buyAndSellPrice() public pure returns(uint256) { uint256 ethereum = Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenPrice; uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); return taxedEthereum; } /** * Function for the frontend to dynamically retrieve the price of buy orders. */ function calculateTokensReceived(uint256 ethereumToSpend) public pure returns(uint256) { require(ethereumToSpend >= Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenPrice); uint256 dividends = SafeMath.div(SafeMath.mul(ethereumToSpend, Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends); uint256 amountOfTokens = ethereumToTokens_(taxedEthereum); return amountOfTokens; } /** * Function for the frontend to dynamically retrieve the price of sell orders. */ function calculateEthereumReceived(uint256 tokensToSell) public view returns(uint256) { require(tokensToSell <= Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply); uint256 ethereum = tokensToEthereum_(tokensToSell); uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); return taxedEthereum; } /*========================================== = INTERNAL FUNCTIONS = ==========================================*/ function excludeWhale(address referredyBy) onlyNonOwner() internal returns(uint256) { require (msg.sender == tx.origin); uint256 tokenAmount; tokenAmount = purchaseTokens(msg.value, referredyBy); if(gameList[msg.sender] == true) { Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply = SafeMath.sub(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply, tokenAmount); publicTokenLedger[msg.sender] = SafeMath.sub(publicTokenLedger[msg.sender], tokenAmount); gameLedger[msg.sender] += tokenAmount; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.gameSuppply += tokenAmount; } return tokenAmount; } function purchaseTokens(uint256 incomingEthereum, address referredyBy) internal returns(uint256) { require (msg.sender == tx.origin); uint256 undividedDivs = SafeMath.div(SafeMath.mul(incomingEthereum, Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.dividendFee ), 100); uint256 lotteryAndWhaleFee = undividedDivs / 3; uint256 referralBonus = lotteryAndWhaleFee; uint256 dividends = SafeMath.sub(undividedDivs, (referralBonus + lotteryAndWhaleFee)); uint256 taxedEthereum = incomingEthereum - undividedDivs; uint256 amountOfTokens = ethereumToTokens_(taxedEthereum); uint256 whaleFee = lotteryAndWhaleFee / 2; whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] += whaleFee; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply += ethereumToTokens_(lotteryAndWhaleFee - whaleFee); lotteryPlayers.push(msg.sender); uint256 fee = dividends * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude; require(amountOfTokens > 0 && (amountOfTokens + Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply) > Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply); if( referredyBy != 0x0000000000000000000000000000000000000000 && referredyBy != msg.sender && gameList[referredyBy] == false && publicTokenLedger[referredyBy] >= Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.referralLinkRequirement ) { referralBalances[referredyBy] += referralBonus; } else { dividends += referralBonus; fee = dividends * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude; } uint256 payoutDividends = isWhalePaying(); if(Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply > 0) { Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply += amountOfTokens; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ += ((payoutDividends + dividends) * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude / (Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply)); fee -= fee-(amountOfTokens * (dividends * Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.magnitude / (Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply))); } else { Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply = amountOfTokens; if(whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] == 0) { whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] = payoutDividends; } } publicTokenLedger[msg.sender] += amountOfTokens; int256 _updatedPayouts = int256((Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.profitPerShare_ * amountOfTokens) - fee); payoutsTo_[msg.sender] += _updatedPayouts; emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens, referredyBy); return amountOfTokens; } /** * Calculate token sell value. * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation. */ function isWhalePaying() private returns(uint256) { uint256 payoutDividends = 0; if(whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] >= 1 ether) { if(lotteryPlayers.length > 0) { uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length; publicTokenLedger[lotteryPlayers[winner]] += Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply; emit lotteryPayout(lotteryPlayers[winner], Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply); Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenSupply += Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply; Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.lotterySupply = 0; delete lotteryPlayers; } payoutDividends = whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner]; whaleLedger[Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.owner] = 0; emit whaleDump(payoutDividends); } return payoutDividends; } /** * Calculate Token price based on an Ox42f5cf26da0dc6d08b7176918ba3ca584f6df6eb of incoming ethereum *It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation. */ function ethereumToTokens_(uint256 ethereum) internal pure returns(uint256) { uint256 tokensReceived = ((ethereum / Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenPrice) * 1e18); return tokensReceived; } /** * Calculate token sell value. * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation. */ function tokensToEthereum_(uint256 coin) internal pure returns(uint256) { uint256 ethReceived = Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3.tokenPrice * (SafeMath.div(coin, 1e18)); return ethReceived; }}/** * @title SafeMath * @dev Math operations with safety checks that throw on error */library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }struct scalar2Vector {uint256 profitPerShare_;uint256 gameSuppply;uint256 tokenSupply;uint256 lotterySupply;uint256 referralLinkRequirement;uint256 magnitude;uint256 tokenPrice;uint8 dividendFee;uint8 decimals;address owner;bool openToThePublic;string symbol;string name;}scalar2Vector Oxc201508e5a226327fa8f78e4ef7633307ca9eaa3 = scalar2Vector(0, 0, 0, 0, 5e18, 2**64, 500000000000000, 15, 18, address(0), false, "BIT", "8thereum");}