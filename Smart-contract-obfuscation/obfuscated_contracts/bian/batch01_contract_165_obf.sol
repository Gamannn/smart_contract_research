pragma solidity ^0.4.24;library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a / _b; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; }}contract BaseLBSCSale { using SafeMath for uint256; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); event Pause(); event Unpause(); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == Ox9c9688ce788e2483608005b314c830fadc246106.owner,"Only the owner is allowed to call this."); _; } modifier onlyOwnerOrManager{ require(msg.sender == Ox9c9688ce788e2483608005b314c830fadc246106.owner || msg.sender == Ox9c9688ce788e2483608005b314c830fadc246106.manager, "Only owner or manager is allowed to call this"); _; } modifier beforeDeadline(){ require (currentTime() < Ox9c9688ce788e2483608005b314c830fadc246106.endTime, "Validation: Before endtime"); _; } modifier afterDeadline(){ require (currentTime() >= Ox9c9688ce788e2483608005b314c830fadc246106.endTime, "Validation: After endtime"); _; } modifier afterStartTime(){ require (currentTime() >= Ox9c9688ce788e2483608005b314c830fadc246106.startTime, "Validation: After starttime"); _; } modifier saleNotClosed(){ require (!Ox9c9688ce788e2483608005b314c830fadc246106.saleClosed, "Sale is not yet ended"); _; } modifier nonReentrant() { require(!Ox9c9688ce788e2483608005b314c830fadc246106.rentrancy_lock, "Validation: Reentrancy"); Ox9c9688ce788e2483608005b314c830fadc246106.rentrancy_lock = true; _; Ox9c9688ce788e2483608005b314c830fadc246106.rentrancy_lock = false; } modifier whenNotPaused() { require(!Ox9c9688ce788e2483608005b314c830fadc246106.paused, "You are not allowed to access this time."); _; } modifier whenPaused() { require(Ox9c9688ce788e2483608005b314c830fadc246106.paused, "You are not allowed to access this time."); _; } constructor() public{ Ox9c9688ce788e2483608005b314c830fadc246106.owner = msg.sender; } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0), "Owner cannot be 0 address."); emit OwnershipTransferred(Ox9c9688ce788e2483608005b314c830fadc246106.owner, _newOwner); Ox9c9688ce788e2483608005b314c830fadc246106.owner = _newOwner; } function pause() public onlyOwnerOrManager whenNotPaused { Ox9c9688ce788e2483608005b314c830fadc246106.paused = true; emit Pause(); } function unpause() public onlyOwnerOrManager whenPaused { Ox9c9688ce788e2483608005b314c830fadc246106.paused = false; emit Unpause(); } function currentTime() public view returns (uint _currentTime) { return block.Ox52ad49430f80f9eb48ba6b6f53b4a33d3254df62; } function terminate() external onlyOwnerOrManager { Ox9c9688ce788e2483608005b314c830fadc246106.saleClosed = true; } function setRate(uint _rate) public onlyOwnerOrManager { Ox9c9688ce788e2483608005b314c830fadc246106.rate = _rate; } function ownerUnlockFund() external afterDeadline onlyOwner { Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoalReached = false; } function checkFundingGoal() internal { if (!Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoalReached) { if (Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised >= Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoal) { Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoalReached = true; emit GoalReached(Ox9c9688ce788e2483608005b314c830fadc246106.beneficiary, Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised); } } } function checkFundingCap() internal { if (!Ox9c9688ce788e2483608005b314c830fadc246106.fundingCapReached) { if (Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised >= Ox9c9688ce788e2483608005b314c830fadc246106.fundingCap) { Ox9c9688ce788e2483608005b314c830fadc246106.fundingCapReached = true; Ox9c9688ce788e2483608005b314c830fadc246106.saleClosed = true; emit CapReached(Ox9c9688ce788e2483608005b314c830fadc246106.beneficiary, Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised); } } } function changeStartTime(uint256 _startTime) external onlyOwnerOrManager {Ox9c9688ce788e2483608005b314c830fadc246106.startTime = _startTime;} function changeEndTime(uint256 _endTime) external onlyOwnerOrManager {Ox9c9688ce788e2483608005b314c830fadc246106.endTime = _endTime;} function changeMinContribution(uint256 _newValue) external onlyOwnerOrManager {Ox9c9688ce788e2483608005b314c830fadc246106.minContribution = _newValue * (10 ** Ox9c9688ce788e2483608005b314c830fadc246106.decimals);}}contract BaseLBSCToken { using SafeMath for uint256; mapping(address => uint256) internal Ox4cf05f2267036bdaff94baee2872073460741452; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f); event Approval(address indexed owner, address indexed spender, uint256 Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f); event Burn(address indexed burner, uint256 Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Mint(address indexed to, uint256 amount); modifier onlyOwner() { require(msg.sender == owner,"Only the owner is allowed to call this."); _; } constructor() public{ owner = msg.sender; } function totalSupply() public view returns (uint256) { return Ox9c9688ce788e2483608005b314c830fadc246106.totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= Ox4cf05f2267036bdaff94baee2872073460741452[msg.sender], "You do not have sufficient balance."); require(_to != address(0), "You cannot send tokens to 0 address"); Ox4cf05f2267036bdaff94baee2872073460741452[msg.sender] = Ox4cf05f2267036bdaff94baee2872073460741452[msg.sender].sub(_value); Ox4cf05f2267036bdaff94baee2872073460741452[_to] = Ox4cf05f2267036bdaff94baee2872073460741452[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return Ox4cf05f2267036bdaff94baee2872073460741452[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool){ require(_value <= Ox4cf05f2267036bdaff94baee2872073460741452[_from], "You do not have sufficient balance."); require(_value <= allowed[_from][msg.sender], "You do not have allowance."); require(_to != address(0), "You cannot send tokens to 0 address"); Ox4cf05f2267036bdaff94baee2872073460741452[_from] = Ox4cf05f2267036bdaff94baee2872073460741452[_from].sub(_value); Ox4cf05f2267036bdaff94baee2872073460741452[_to] = Ox4cf05f2267036bdaff94baee2872073460741452[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f afterwards: * https: * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256){ return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint256 _addedValue) public returns (bool){ allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool){ uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= Ox4cf05f2267036bdaff94baee2872073460741452[_who], "Insufficient balance of tokens"); Ox4cf05f2267036bdaff94baee2872073460741452[_who] = Ox4cf05f2267036bdaff94baee2872073460741452[_who].sub(_value); Ox9c9688ce788e2483608005b314c830fadc246106.totalSupply_ = Ox9c9688ce788e2483608005b314c830fadc246106.totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } /** * @dev Burns a specific amount of tokens from the Oxb5f6f9db2e3cb34362f5f16e9606872aa26c575f address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender], "Insufficient allowance to burn tokens."); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0), "Owner cannot be 0 address."); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; }}contract LBSCToken is BaseLBSCToken { /** * The listed addresses are not valid recipients of tokens. * * 0x0 - the zero address is not valid * this - the contract itself should not receive tokens * owner - the owner has all the initial tokens, but cannot receive any back * adminAddr - the Oxe679ac500fb5f36cfd7839ee9a82847a73b2a1bb has an allowance of tokens to transfer, but does not receive any * crowdSaleAddr - the crowdsale has an allowance of tokens to transfer, but does not receive any */ modifier validDestination(address _to) { require(_to != address(0x0), "Cannot send to 0 address"); require(_to != address(this), "Cannot send to contract address"); _; } constructor(address _admin) public { require(msg.sender != _admin, "Owner and Oxe679ac500fb5f36cfd7839ee9a82847a73b2a1bb cannot be the same"); Ox9c9688ce788e2483608005b314c830fadc246106.totalSupply_ = Ox9c9688ce788e2483608005b314c830fadc246106.INITIAL_SUPPLY; Ox9c9688ce788e2483608005b314c830fadc246106.adminAllowance = Ox9c9688ce788e2483608005b314c830fadc246106.ADMIN_ALLOWANCE; Ox4cf05f2267036bdaff94baee2872073460741452[_admin] = Ox9c9688ce788e2483608005b314c830fadc246106.adminAllowance; emit Transfer(address(0x0), _admin, Ox9c9688ce788e2483608005b314c830fadc246106.adminAllowance); Ox9c9688ce788e2483608005b314c830fadc246106.adminAddr = _admin; approve(Ox9c9688ce788e2483608005b314c830fadc246106.adminAddr, Ox9c9688ce788e2483608005b314c830fadc246106.adminAllowance); } /** * Overrides ERC20 transfer function with modifier that prevents the * ability to transfer tokens until after transfers have been enabled. */ function transfer(address _to, uint256 _value) public validDestination(_to) returns (bool) { return super.transfer(_to, _value); } /** * Overrides ERC20 transferFrom function with modifier that prevents the * ability to transfer tokens until after transfers have been enabled. */ function transferFrom(address _from, address _to, uint256 _value) public validDestination(_to) returns (bool) { bool result = super.transferFrom(_from, _to, _value); if (result) { if (msg.sender == Ox9c9688ce788e2483608005b314c830fadc246106.adminAddr) Ox9c9688ce788e2483608005b314c830fadc246106.adminAllowance = Ox9c9688ce788e2483608005b314c830fadc246106.adminAllowance.sub(_value); } return result; }}contract LBSCSale is BaseLBSCSale { using SafeMath for uint256; LBSCToken public tokenReward; mapping(address => bool) public approvedUsers; /** * Constructor for a crowdsale of CHPToken tokens. * * @param ifSuccessfulSendTo the beneficiary of the Oxd436d35453a5e934f069b9ddca924d929a502c60 * @param fundingGoalInEthers the minimum goal to be reached * @param fundingCapInEthers the cap (maximum) size of the Oxd436d35453a5e934f069b9ddca924d929a502c60 * @param minimumContribution Minimum contribution to participate in the crowdsale * @param start the start time (UNIX Ox52ad49430f80f9eb48ba6b6f53b4a33d3254df62) * @param end the end time (UNIX Ox52ad49430f80f9eb48ba6b6f53b4a33d3254df62) * @param rateLBSCToEther the conversion rate from LBSC to Ether * @param addressOfTokenUsedAsReward address of the token being sold * @param _manager Address that will manage the crowdsale */ constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateLBSCToEther, address addressOfTokenUsedAsReward, address _manager ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), "Beneficiary cannot be 0 address"); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), "Token address cannot be 0 address"); require(fundingGoalInEthers <= fundingCapInEthers, "Funding goal should be less that funding cap."); require(end > 0, "Endtime cannot be 0"); Ox9c9688ce788e2483608005b314c830fadc246106.beneficiary = ifSuccessfulSendTo; Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoal = fundingGoalInEthers; Ox9c9688ce788e2483608005b314c830fadc246106.fundingCap = fundingCapInEthers; Ox9c9688ce788e2483608005b314c830fadc246106.minContribution = minimumContribution; Ox9c9688ce788e2483608005b314c830fadc246106.startTime = start; Ox9c9688ce788e2483608005b314c830fadc246106.endTime = end; Ox9c9688ce788e2483608005b314c830fadc246106.rate = rateLBSCToEther; tokenReward = LBSCToken(addressOfTokenUsedAsReward); Ox9c9688ce788e2483608005b314c830fadc246106.manager = _manager; Ox9c9688ce788e2483608005b314c830fadc246106.decimals = tokenReward.decimals(); } /** * This fallback function is called whenever Ether is sent to the * smart contract. It can only be executed when the crowdsale is * not paused, not closed, and before the deadline has been reached. * * This function will update state variables for whether or not the * funding goal or cap have been reached. It also ensures that the * tokens are transferred to the sender, and that the correct * number of tokens are sent according to the current rate. */ function () public payable whenNotPaused beforeDeadline afterStartTime saleNotClosed nonReentrant { require(msg.Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f >= Ox9c9688ce788e2483608005b314c830fadc246106.minContribution, "Value should be greater than minimum contribution"); require(isApprovedUser(msg.sender), "Only the approved users are allowed to participate in ICO"); uint amount = msg.Oxa77d8ce04da1c9aa813d0820005b06f7ee1b838f; uint currentBalance = balanceOf[msg.sender]; balanceOf[msg.sender] = currentBalance.add(amount); Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised = Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised.add(amount); uint numTokens = amount.mul(Ox9c9688ce788e2483608005b314c830fadc246106.rate); if (tokenReward.transferFrom(tokenReward.owner(), msg.sender, numTokens)) { emit FundTransfer(msg.sender, amount, true); checkFundingGoal(); checkFundingCap(); } else { revert("Transaction Failed. Please try again later."); } } /** * The owner can allocate the specified amount of tokens from the * crowdsale allowance to the recipient (_to). * * NOTE: be extremely careful to get the amounts correct, which * are in units of wei and mini-LBSC. Every digit counts. * * @param _to the recipient of the tokens * @param amountInEth the amount contributed in wei * @param amountLBSC the amount of tokens transferred in mini-LBSC (18 decimals) */ function ownerAllocateTokens(address _to, uint amountInEth, uint amountLBSC) public onlyOwnerOrManager nonReentrant { if (!tokenReward.transferFrom(tokenReward.owner(), _to, convertToMini(amountLBSC))) { revert("Transfer failed. Please check allowance"); } uint amountWei = convertToMini(amountInEth); balanceOf[_to] = balanceOf[_to].add(amountWei); Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised = Ox9c9688ce788e2483608005b314c830fadc246106.amountRaised.add(amountWei); emit FundTransfer(_to, amountWei, true); checkFundingGoal(); checkFundingCap(); } /** * The owner can call this function to Ox85226393a4c01efb6183beec173a0e88761464d3 the funds that * have been sent to this contract for the crowdsale subject to * the funding goal having been reached. The funds will be sent * to the beneficiary specified when the crowdsale was created. */ function ownerSafeWithdrawal() public onlyOwner nonReentrant { require(Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoalReached, "Check funding goal"); uint balanceToSend = address(this).balance; Ox9c9688ce788e2483608005b314c830fadc246106.beneficiary.transfer(balanceToSend); emit FundTransfer(Ox9c9688ce788e2483608005b314c830fadc246106.beneficiary, balanceToSend, false); } /** * This function permits anybody to Ox85226393a4c01efb6183beec173a0e88761464d3 the funds they have * contributed if and only if the deadline has passed and the * funding goal was not reached. */ function safeWithdrawal() public afterDeadline nonReentrant { if (!Ox9c9688ce788e2483608005b314c830fadc246106.fundingGoalReached) { uint amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount > 0) { msg.sender.transfer(amount); emit FundTransfer(msg.sender, amount, false); Ox9c9688ce788e2483608005b314c830fadc246106.refundAmount = Ox9c9688ce788e2483608005b314c830fadc246106.refundAmount.add(amount); } } } function convertToMini(uint amount) internal view returns (uint) { return amount * (10 ** Ox9c9688ce788e2483608005b314c830fadc246106.decimals); } function approveUser(address _address) external onlyOwnerOrManager { approvedUsers[_address] = true; } function disapproveUser(address _address) external onlyOwnerOrManager { approvedUsers[_address] = false; } function changeManager(address _manager) external onlyOwnerOrManager { Ox9c9688ce788e2483608005b314c830fadc246106.manager = _manager; } function isApprovedUser(address _address) internal view returns (bool) { return approvedUsers[_address]; } function changeTokenAddress(address _address) external onlyOwnerOrManager { tokenReward = LBSCToken(_address); }struct scalar2Vector {bool transferEnabled;address adminAddr;uint256 adminAllowance;uint256 ADMIN_ALLOWANCE;uint256 INITIAL_SUPPLY;uint8 decimals;string symbol;string name;uint256 totalSupply_;address owner;address manager;bool rentrancy_lock;uint256 rate;uint256 refundAmount;uint256 amountRaised;uint256 endTime;uint256 startTime;bool saleClosed;bool fundingCapReached;bool fundingGoalReached;uint256 decimals;uint256 minContribution;uint256 fundingCap;uint256 fundingGoal;address beneficiary;bool paused;address owner;}scalar2Vector Ox9c9688ce788e2483608005b314c830fadc246106 = scalar2Vector( true, address(0), 0, 30000000 * (10 ** uint256(decimals)), 30000000 * (10 ** uint256(decimals)), 18, "LBSC", "LabelsCoin", 0, address(0), address(0), false, 220, 0, 0, 0, 0, false, false, false, 0, 0, 0, 0, address(0), false, address(0));}