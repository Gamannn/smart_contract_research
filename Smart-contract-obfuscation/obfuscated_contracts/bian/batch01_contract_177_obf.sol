pragma solidity ^0.4.11;library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } }}contract ownable { modifier onlyOwner { if (!isOwner(msg.sender)) throw; _; } function ownable() { Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.owner = msg.sender; } function transferOwnership(address _newOwner) onlyOwner { Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.owner = _newOwner; } function isOwner(address _address) returns (bool) { return Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.owner == _address; }}contract Burnable { event Burn(address indexed owner, uint Oxa939b8939fb8ea314ba7b1798f4ded7e5b0e18ea); function burn(address _owner, uint _amount) public;}contract ERC20 { function totalSupply() constant returns (uint); function Ox1b0d93004ecc29926801f63a6c8fe34228153847(address _owner) constant returns (uint); function allowance(address _owner, address _spender) constant returns (uint); function Oxd1c8935b1a5e9e7d7538c0b159ed8e63cebc95c3(address _to, uint _value) returns (bool); function transferFrom(address _from, address _to, uint _value) returns (bool); function approve(address _spender, uint _value) returns (bool); event Approval(address indexed owner, address indexed spender, uint value); event Transfer(address indexed from, address indexed to, uint value);}contract Mintable { event Mint(address indexed to, uint value); function mint(address _to, uint _amount) public;}contract Token is ERC20, Mintable, Burnable, ownable { using SafeMath for uint; string public name; string public symbol; mapping (address => mapping (address => uint)) allowed; mapping (address => uint) balances; modifier canMint { require(totalSupply < Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.maxSupply); _; } modifier mintIsNotFrozen { require(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.freezeMintUntil < now); _; } function Token(string _name, string _symbol, uint _maxSupply) { name = _name; symbol = _symbol; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.maxSupply = _maxSupply; totalSupply = 0; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.freezeMintUntil = 0; } function totalSupply() constant returns (uint) { return totalSupply; } function Ox1b0d93004ecc29926801f63a6c8fe34228153847(address _owner) constant returns (uint) { return balances[_owner]; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } function Oxd1c8935b1a5e9e7d7538c0b159ed8e63cebc95c3(address _to, uint _value) returns (bool) { if (_value <= 0) { return false; } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (_value <= 0) { return false; } balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function mint(address _to, uint _amount) public canMint mintIsNotFrozen onlyOwner { if (Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.maxSupply < totalSupply.add(_amount)) throw; totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); } function burn(address _owner, uint _amount) public onlyOwner { totalSupply = totalSupply.sub(_amount); balances[_owner] = balances[_owner].sub(_amount); Burn(_owner, _amount); } function freezeMintingFor(uint _weeks) public onlyOwner { Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.freezeMintUntil = now + _weeks * 1 weeks; }}contract TokenSale is ownable { using SafeMath for uint; Token public Ox9da6711a837d6d07927658236828f1f807f68670; mapping (address => uint) contributed; mapping (address => bool) whitelisted; event GoalReached(uint Ox95067988581db5bc755d00ffb64b5f56bba65aba); event NewContribution(address indexed holder, uint256 tokens, uint256 contributed); event Refunded(address indexed Ox9c56ef6f6e47cca331dc305fbce509862fc7b452, uint Oxa939b8939fb8ea314ba7b1798f4ded7e5b0e18ea); modifier onlyAfterSale { require(block.number > Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.endBlock); _; } modifier onlyWhenFinalized { require(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.isFinalized); _; } modifier onlyDuringSale { require(block.number >= startBlock(msg.sender)); require(block.number <= Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.endBlock); _; } modifier onlyWhenEnded { if (block.number < Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.endBlock && !Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.capReached) throw; _; } function TokenSale( uint _cap, uint _whitelistStartBlock, uint _startBlock, uint _endBlock, address _token, uint _price, uint _purchaseLimit, address _beneficiary ) { Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.cap = _cap * 1 ether; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.price = _price; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.purchaseLimit = (_purchaseLimit * 1 ether) * Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.price; Ox9da6711a837d6d07927658236828f1f807f68670 = Token(_token); Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.Ox9c56ef6f6e47cca331dc305fbce509862fc7b452 = _beneficiary; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.whitelistStartBlock = _whitelistStartBlock; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.startBlock = _startBlock; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.endBlock = _endBlock; } function () payable { doPurchase(msg.sender); } function refund() public onlyWhenFinalized { if (Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.capReached) throw; uint balance = Ox9da6711a837d6d07927658236828f1f807f68670.Ox1b0d93004ecc29926801f63a6c8fe34228153847(msg.sender); if (balance == 0) throw; uint refund = balance.div(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.price); if (refund > this.balance) { refund = this.balance; } Ox9da6711a837d6d07927658236828f1f807f68670.burn(msg.sender, balance); contributed[msg.sender] = 0; msg.sender.Oxd1c8935b1a5e9e7d7538c0b159ed8e63cebc95c3(refund); Refunded(msg.sender, refund); } function finalize() public onlyWhenEnded onlyOwner { require(!Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.isFinalized); Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.isFinalized = true; if (!Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.capReached) { return; } if (!Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.Ox9c56ef6f6e47cca331dc305fbce509862fc7b452.send(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected)) throw; Ox9da6711a837d6d07927658236828f1f807f68670.freezeMintingFor(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.MINT_LOCK_DURATION_IN_WEEKS); } function doPurchase(address _owner) internal onlyDuringSale { if (msg.value <= 0) throw; if (Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected >= Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.cap) throw; uint value = msg.value; if (Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected.add(value) > Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.cap) { uint difference = Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.cap.sub(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected); msg.sender.Oxd1c8935b1a5e9e7d7538c0b159ed8e63cebc95c3(value.sub(difference)); value = difference; } uint tokens = value.mul(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.price); if (Ox9da6711a837d6d07927658236828f1f807f68670.Ox1b0d93004ecc29926801f63a6c8fe34228153847(msg.sender) + tokens > Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.purchaseLimit) throw; Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected = Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected.add(value); Ox9da6711a837d6d07927658236828f1f807f68670.mint(msg.sender, tokens); NewContribution(_owner, tokens, value); if (Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected != Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.cap) { return; } GoalReached(Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.collected); Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.capReached = true; } function addToWhitelist(address _address) public onlyOwner { whitelisted[_address] = true; } function startBlock(address contributor) constant returns (uint) { if (whitelisted[contributor]) { return Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.whitelistStartBlock; } return Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.startBlock; } function tokenTransferOwnership(address _newOwner) public onlyWhenFinalized { if (!Oxbe0e43c0126474455ce6bb5965bafa3903a78aab.capReached) throw; Ox9da6711a837d6d07927658236828f1f807f68670.transferOwnership(_newOwner); }struct scalar2Vector {bool isFinalized;bool capReached;uint256 endBlock;uint256 startBlock;uint256 whitelistStartBlock;uint256 purchaseLimit;uint256 price;uint256 collected;uint256 cap;address Ox9c56ef6f6e47cca331dc305fbce509862fc7b452;uint256 MINT_LOCK_DURATION_IN_WEEKS;uint256 freezeMintUntil;uint256 totalSupply;uint256 maxSupply;uint256 decimals;uint256 totalSupply;address owner;}scalar2Vector Oxbe0e43c0126474455ce6bb5965bafa3903a78aab = scalar2Vector( false, false, 0, 0, 0, 0, 0, 0, 0, address(0), 26, 0, 0, 0, 18, 0, address(0));}